;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; view.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defparameter *attachments* t)

(eval-when (compile load eval)
  (proclaim '(special *ancestry* *consistency* *depth* *limit*
                      *unifications* *inferences* *termination*
                      *thing* *theory* *filter* *variables*
                      *answer* *answers* *residue* *attachments*
                      alist level tracecalls traceexpressions)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; viewfindp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun viewfindp (p th)
  (viewfindx 't p th))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; viewfindx
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun viewfindx (*thing* p *theory*)
  (let (alist *answer*)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq alist (environment))
    (when (viewone p (list p) alist 0 nil) *answer*)))

(defun viewone (p pl al depth cont)
  (setq *inferences* (1+ *inferences*))
  (viewcall p al depth)
  (cond ((>= *inferences* *limit*) (setq *termination* t) (viewstop (car pl) al depth))
        ((>= depth *depth*) (setq *termination* t) (viewstop (car pl) al depth))
        (t (viewoneexp p pl al depth cont))))

(defun viewoneexp (p pl al depth cont)
  (cond ((atom p) (viewoneconstant p pl al depth cont))
        ((eq (car p) 'not) (viewoneunprovable p pl al depth cont))
        ((eq (car p) 'and) (viewoneand p pl al depth cont))
        ((eq (car p) 'or) (viewoneor p pl al depth cont))
        ((eq (car p) 'same) (viewonesame p pl al depth cont))
        ((eq (car p) 'distinct) (viewonedistinct p pl al depth cont))
        ((and *attachments* (eq (car p) 'oneof)) (viewoneoneof p pl al depth cont))
        ((and *attachments* (eq (car p) 'choose)) (viewonechoose p pl al depth cont))
        ((and *attachments* (eq (car p) 'bagofall)) (viewonebagofall p pl al depth cont))
        ((and *attachments* (eq (car p) 'unprovable)) (viewoneunprovable p pl al depth cont))
	((and *attachments* (eq (car p) 'ground)) (viewoneground p pl al depth cont))
	((and *attachments* (eq (car p) 'nonground)) (viewonenonground p pl al depth cont))
        ((and *attachments* (eq (car p) 'execute)) (viewoneexecute p pl al depth cont))
        ((and *attachments* (eq (car p) 'evaluate)) (viewoneevaluate p pl al depth cont))
        ((and *attachments* (eq (car p) 'stringmatch)) (viewonestringmatch p pl al depth cont))
	((and *attachments* (get (car p) 'basicval)) (viewonebasicval p pl al depth cont))
        ((and *attachments* (get (car p) 'basic)) (viewonebasic p pl al depth cont))
        (t (viewoners p pl al depth cont))))

(defun viewoneconstant (p pl al depth cont)
  (cond ((eq 'true p) (viewonelast pl al depth cont))
        ((eq 'false p) (viewfail (car pl) al depth))
        (t (viewoners p pl al depth cont))))

(defun viewoneand (p pl al depth cont)
  (cond ((null (cdr p)) (viewonelast pl al depth cont))
        ((viewone (cadr p) (cdr p) al depth (cons (list pl al depth) cont)))
        (t (viewfail (car pl) al depth))))

(defun viewoneor (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (viewfail (car pl) al depth))
      (when (viewone (car l) (list (car l)) al depth cont)
        (return t))))

(defun viewonesame (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (prog1 (viewonelast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewonedistinct (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (backup ol) (viewfail (car pl) al depth))
          (t (viewonelast pl al depth cont)))))

(defun viewoneoneof (p pl al depth cont)
  (when (seqvarp (caddr p)) (setq p (plug p al)))
  (do ((l (cddr p) (cdr l)) (ol))
      ((null l) (viewfail (car pl) al depth))
      (cond ((not (setq ol (unify (cadr p) al (car l) al))))
            ((viewoneexit pl al depth cont) (backup ol) (return t))
            (t (backup ol)))))

(defun viewonechoose (p pl al depth cont)
  (let (x ol)
    (setq p (plugstdexp p al))
    (setq x (viewfindx (cadr p) (caddr p) *theory*))
    (cond ((and (not (null x)) (setq ol (unify (cadddr p) alist x alist)))
           (prog1 (viewonelast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewonebagofall (p pl al depth cont)
  (let (answer ol)
    (setq p (plug p al))
    (setq answer (cons 'listof (viewfinds (cadr p) (caddr p) *theory*)))
    (cond ((setq ol (unify answer al (cadddr p) al))
           (prog1 (viewonelast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewoneunprovable (p pl al depth cont)
  (cond ((viewone (cadr p) (cdr p) al depth nil) (viewfail (car pl) al depth))
        (t (viewonelast pl al depth cont))))

(defun viewoneground (p pl al depth cont)
  (cond ((and (groundp (plug (cadr p) al))) (viewonelast pl al depth cont))
        (t (viewfail (car pl) al depth))))

(defun viewonenonground (p pl al depth cont)
  (cond ((groundp (plug (cadr p) al)) (viewfail (car pl) al depth))
        (t (viewonelast pl al depth cont))))

(defun viewoneexecute (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (eval (cadr p)))
                  (viewonelast pl al depth cont))
                 (t (viewfail (car pl) al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))
           (prog1 (viewonelast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewoneevaluate (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((viewevals (cadr p)) (viewonelast pl al depth cont))
                 (t (viewfail (car pl) al depth))))
          ((and (car (setq values (viewevals (cadr p))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al)))
           (prog1 (viewonelast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewevals (x)
  (cond ((atom x) (ignore-errors (list (eval x))))
        (t (ignore-errors (multiple-value-list (apply (car x) (cdr x)))))))

(defun viewonestringmatch (p pl al depth cont)
  (viewoneexp `(execute (stringmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun viewonebasicval (p pl al depth cont)
  (let (x y ol)
    (setq p (plug p al) x (butlast p) y (car (last p)))
    (cond ((not (groundp x)) (viewfail (car pl) al depth))
          ((setq ol (unify (funcall (get (car x) 'basicval) x) al y al))
           (prog1 (viewonelast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewonebasic (p pl al depth cont)
  (setq p (plug p al))
  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p)))
         (viewonelast pl al depth cont))
        (t (viewfail (car pl) al depth))))

(defun viewoners (p pl al depth cont)
  (cond ((and *ancestry* (viewoneancestor p al cont)) (viewfail (car pl) al depth))
        ((viewonedb p pl al depth cont *theory*))
        (t (viewfail (car pl) al depth))))

(defun viewoneancestor (p al cont)
  (do ((l (cdr cont) (cdr l)))
      ((null l) nil)
      (if (identify (caaar l) (cadar l) p al) (return t))))

(defun viewonedb (p pl al depth cont th)
  (cond ((viewoneth p pl al depth cont th))
        (t (do ((l (includees th) (cdr l)))
               ((null l) nil)
               (when (viewonedb p pl al depth cont (car l)) (return t))))))

(defun viewoneth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))
             (cond ((not (setq ol (unify (cadar l) bl p al))))
                   ((viewoneexit pl al depth cont) (backup ol) (return t))
                   ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol))))
            ((and (listp (car l)) (eq '<= (caar l)))
             (cond ((not (setq ol (unify (cadar l) bl p al))))
                   ((viewone (caddar l) (cddar l) bl
                             (1+ depth) (cons (list pl al depth) cont))
                    (backup ol) (return  t))
                   (t (backup ol))))
            ((setq ol (unify (car l) bl p al))
             (cond ((viewoneexit pl al depth cont) (backup ol) (return t))
                   ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun viewoneexit (pl al depth cont)
  (let (ans)
    (viewexit (car pl) al depth)
    (cond ((cdr pl) (setq ans (viewone (cadr pl) (cdr pl) al depth cont)))
          (cont (setq ans (viewoneexit (caar cont) (cadar cont) (caddar cont) (cdr cont))))
          (t (setq *answer* (plugstdexp *thing* alist) ans t)))
    (if ans t (viewredo (car pl) al depth))))

(defun viewonelast (pl al depth cont)
  (viewexit (car pl) al depth)
  (cond ((cdr pl) (viewone (cadr pl) (cdr pl) al depth cont))
        (cont (viewoneexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
        (t (setq *answer* (plugstdexp *thing* alist)))))

(defun viewcall (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Call: | p) nil)))

(defun viewexit (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Exit: | p) nil)))

(defun viewredo (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Redo: | p) nil)))

(defun viewfail (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Fail: | p) nil)))

(defun viewstop (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Stop: | p) nil)))

(defun viewsave (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Save: | p) nil)))

(defun viewdrop (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Drop: | p) nil)))

(defun viewdone (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Done: | p) nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; viewfinds
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun viewfinds (*thing* p *theory*)
  (let (alist *answers*)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq alist (environment))
    (viewall p (list p) alist 0 nil)
    (nreverse (uniquify *answers*))))

(defun viewall (p pl al depth cont)
  (setq *inferences* (1+ *inferences*))
  (viewcall p al depth)
  (cond ((>= *inferences* *limit*) (setq *termination* t) (viewstop (car pl) al depth))
        ((>= depth *depth*) (setq *termination* t) (viewstop (car pl) al depth))
        (t (viewallexp p pl al depth cont))))

(defun viewallexp (p pl al depth cont)
  (cond ((atom p) (viewallconstant p pl al depth cont))
        ((eq (car p) 'not) (viewallunprovable p pl al depth cont))
        ((eq (car p) 'and) (viewalland p pl al depth cont))
        ((eq (car p) 'or) (viewallor p pl al depth cont))
        ((eq (car p) 'same) (viewallsame p pl al depth cont))
        ((eq (car p) 'distinct) (viewalldistinct p pl al depth cont))
        ((and *attachments* (eq (car p) 'oneof)) (viewalloneof p pl al depth cont))
        ((and *attachments* (eq (car p) 'choose)) (viewallchoose p pl al depth cont))
        ((and *attachments* (eq (car p) 'bagofall)) (viewallbagofall p pl al depth cont))
        ((and *attachments* (eq (car p) 'unprovable)) (viewallunprovable p pl al depth cont))
	((and *attachments* (eq (car p) 'ground)) (viewallground p pl al depth cont))
	((and *attachments* (eq (car p) 'nonground)) (viewallnonground p pl al depth cont))
        ((and *attachments* (eq (car p) 'execute)) (viewallexecute p pl al depth cont))
        ((and *attachments* (eq (car p) 'evaluate)) (viewallevaluate p pl al depth cont))
        ((and *attachments* (eq (car p) 'stringmatch)) (viewallstringmatch p pl al depth cont))
	((and *attachments* (get (car p) 'basicval)) (viewallbasicval p pl al depth cont))
        ((and *attachments* (get (car p) 'basic)) (viewallbasic p pl al depth cont))
        (t (viewallrs p pl al depth cont))))

(defun viewallconstant (p pl al depth cont)
  (cond ((eq p 'true) (viewalllast pl al depth cont))
        ((eq p 'false) (viewfail (car pl) al depth))
        (t (viewallrs p pl al depth cont))))

(defun viewalland (p pl al depth cont)
  (cond ((null (cdr p)) (viewalllast pl al depth cont))
        ((viewall (cadr p) (cdr p) al depth (cons (list pl al depth) cont)))
        (t (viewfail (car pl) al depth))))

(defun viewallor (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (viewfail (car pl) al depth))
      (viewall (car l) (list (car l)) al depth cont)))

(defun viewallsame (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (viewalllast pl al depth cont)
           (backup ol))
          (t (viewfail p al depth)))))

(defun viewalldistinct (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (backup ol) (viewfail p al depth))
          (t (viewalllast pl al depth cont)))))

(defun viewalloneof (p pl al depth cont)
  (when (seqvarp (caddr p)) (setq p (plug p al)))
  (do ((l (cddr p) (cdr l)) (ol))
      ((null l) (viewfail (car pl) al depth))
      (when (setq ol (unify (cadr p) al (car l) al))
        (viewallexit pl al depth cont)
        (backup ol))))

(defun viewallchoose (p pl al depth cont)
  (let (x ol)
    (setq p (plugstdexp p al))
    (setq x (viewfindx (cadr p) (caddr p) *theory*))
    (cond ((and (not (null x)) (setq ol (unify (cadddr p) alist x alist)))
           (prog1 (viewallexit pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewallbagofall (p pl al depth cont)
  (let (answer ol)
    (setq p (plug p al))
    (setq answer (cons 'listof (viewfinds (cadr p) (caddr p) *theory*)))
    (cond ((setq ol (unify answer al (cadddr p) al))
           (prog1 (viewalllast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewallunprovable (p pl al depth cont)
  (cond ((viewone (cadr p) (cdr p) al depth nil) (viewfail (car pl) al depth))
        (t (viewalllast pl al depth cont))))

(defun viewallground (p pl al depth cont)
  (setq p (plug p al))
  (if (groundp p) (viewallexit pl al depth cont)))

(defun viewallnonground (p pl al depth cont)
  (setq p (plug p al))
  (if (groundp p) nil (viewallexit pl al depth cont)))

(defun viewallexecute (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (eval (cadr p))) (viewallexit pl al depth cont))
                 (t (viewfail (car pl) al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))
           (prog1 (viewallexit pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewallevaluate (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((viewevals (cadr p)) (viewallexit pl al depth cont))
                 (t (viewfail (car pl) al depth))))
          ((and (car (setq values (viewevals (cadr p))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al)))
           (prog1 (viewallexit pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewallstringmatch (p pl al depth cont)
  (viewallexp `(execute (stringmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun viewallbasicval (p pl al depth cont)
  (let (x y ol)
    (setq p (plug p al) x (butlast p) y (car (last p)))
    (cond ((not (groundp x)) (viewfail (car pl) al depth))
          ((setq ol (unify (funcall (get (car x) 'basicval) x) al y al))
           (prog1 (viewalllast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewallbasic (p pl al depth cont)
  (setq p (plug p al))
  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p))
              (viewallexit pl al depth cont)))
        (t (viewfail (car pl) al depth))))

(defun viewallrs (p pl al depth cont)
  (cond ((and *ancestry* (viewallancestor p al cont)) (viewfail (car pl) al depth))
        ((and (numberp *ancestry*) (viewallnumber p al cont 0))
         (setq *termination* t) (viewfail (car pl) al depth))
        ((viewalldb p pl al depth cont *theory*))
        (t (viewfail (car pl) al depth))))

(defun viewallancestor (p al cont)
  (do ((l cont (cdr l)))
      ((null l) nil)
      (if (identify (caaar l) (cadar l) p al) (return t))))

(defun viewallnumber (p al cont n)
  (let (ol)
    (cond ((numgeqp n *ancestry*))
          ((null cont) nil)
          ((atom p)
           (viewallnumber p al (cdr cont) (if (eq p (caaar cont)) (1+ n) n)))
          ((setq ol (unify p al (caaar cont) (cadar cont)))
           (prog1 (viewallnumber p al (cdr cont) (1+ n)) (backup ol)))
          (t (viewallnumber p al (cdr cont) n)))))

(defun viewalldb (p pl al depth cont th)
  (viewallth p pl al depth cont th)
  (do ((l (includees th) (cdr l)))
      ((null l))
      (viewalldb p pl al depth cont (car l))))

(defun viewallth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (viewallexit pl al depth cont)
               (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))
            ((and (listp (car l)) (eq '<= (caar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (viewall (caddar l) (cddar l) bl
                        (1+ depth) (cons (list pl al depth) cont))
               (backup ol)))
            ((setq ol (unify (car l) bl p al))
             (viewallexit pl al depth cont)
             (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun viewallexit (pl al depth cont)
  (viewexit (car pl) al depth)
  (cond ((cdr pl) (viewall (cadr pl) (cdr pl) al depth cont))
        (cont (viewallexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
        (t (setq *answers* (cons (plugstdexp *thing* alist) *answers*))))
  (viewredo (car pl) al depth))

(defun viewalllast (pl al depth cont)
  (viewexit (car pl) al depth)
  (cond ((cdr pl) (viewall (cadr pl) (cdr pl) al depth cont))
        (cont (viewallexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
        (t (setq *answers* (cons (plugstdexp *thing* alist) *answers*)) nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; viewsupports: viewfinds but returns supporting data as well
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun viewsupports (*thing* p *theory* &optional (*filter* #'failure))
  (let (alist *answers* *residue*)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq alist (environment))
    (viewsupps p (list p) alist 0 nil)
    (nreverse (uniquify *answers*))))

(defun viewsupps (p pl al depth cont)
  (setq *inferences* (1+ *inferences*))
  (viewcall p al depth)
  (cond ((>= *inferences* *limit*) (setq *termination* t) (viewstop (car pl) al depth))
        ((>= depth *depth*) (setq *termination* t) (viewstop (car pl) al depth))
        (t (viewsuppsexp p pl al depth cont))))

(defun viewsuppsexp (p pl al depth cont)
  (cond ((atom p) (viewsuppsconstant p pl al depth cont))
        ((eq (car p) 'not) (viewsuppsunprovable p pl al depth cont))
        ((eq (car p) 'and) (viewsuppsand p pl al depth cont))
        ((eq (car p) 'or) (viewsuppsor p pl al depth cont))
        ((eq (car p) 'same) (viewsuppssame p pl al depth cont))
        ((eq (car p) 'distinct) (viewsuppsdistinct p pl al depth cont))
        ((and *attachments* (eq (car p) 'oneof)) (viewsuppsoneof p pl al depth cont))
        ((and *attachments* (eq (car p) 'choose)) (viewsuppschoose p pl al depth cont))
        ((and *attachments* (eq (car p) 'bagofall)) (viewsuppsbagofall p pl al depth cont))
        ((and *attachments* (eq (car p) 'unprovable)) (viewsuppsunprovable p pl al depth cont))
	((and *attachments* (eq (car p) 'ground)) (viewsuppsground p pl al depth cont))
	((and *attachments* (eq (car p) 'nonground)) (viewsuppsnonground p pl al depth cont))
        ((and *attachments* (eq (car p) 'execute)) (viewsuppsexecute p pl al depth cont))
        ((and *attachments* (eq (car p) 'evaluate)) (viewsuppsevaluate p pl al depth cont))
        ((and *attachments* (eq (car p) 'stringmatch)) (viewsuppsstringmatch p pl al depth cont))
	((and *attachments* (get (car p) 'basicval)) (viewsuppsbasicval p pl al depth cont))
        ((and *attachments* (get (car p) 'basic)) (viewsuppsbasic p pl al depth cont))
        (t (viewsuppsrs p pl al depth cont))))

(defun viewsuppsconstant (p pl al depth cont)
  (cond ((eq p 'true) (viewsuppslast pl al depth cont))
        ((eq p 'false) (viewsuppsfail (car pl) al depth))
        (t (viewsuppsrs p pl al depth cont))))

(defun viewsuppsand (p pl al depth cont)
  (cond ((null (cdr p)) (viewsuppslast pl al depth cont))
        ((viewsupps (cadr p) (cdr p) al depth (cons (list pl al depth) cont)))
        (t (viewsuppsfail (car pl) al depth))))

(defun viewsuppsor (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (viewsuppsfail (car pl) al depth))
      (viewsupps (car l) (list (car l)) al depth cont)))

(defun viewsuppssame (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (viewsuppslast pl al depth cont)
           (backup ol))
          (t (viewsuppsfail p al depth)))))

(defun viewsuppsdistinct (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (backup ol) (viewsuppsfail p al depth))
          (t (viewsuppslast pl al depth cont)))))

(defun viewsuppsoneof (p pl al depth cont)
  (when (seqvarp (caddr p)) (setq p (plug p al)))
  (do ((l (cddr p) (cdr l)) (ol))
      ((null l) (viewsuppsfail (car pl) al depth))
      (when (setq ol (unify (cadr p) al (car l) al))
        (viewsuppsexit pl al depth cont)
        (backup ol))))

(defun viewsuppschoose (p pl al depth cont)
  (let (x ol)
    (setq p (plugstdexp p al))
    (setq x (viewfindx (cadr p) (caddr p) *theory*))
    (cond ((and (not (null x)) (setq ol (unify (cadddr p) alist x alist)))
           (prog1 (viewsuppsexit pl al depth cont) (backup ol)))
          (t (viewsuppsfail (car pl) al depth)))))

(defun viewsuppsbagofall (p pl al depth cont)
  (let (answer ol)
    (setq p (plug p al))
    (setq answer (cons 'listof (viewfinds (cadr p) (caddr p) *theory*)))
    (cond ((setq ol (unify answer al (cadddr p) al))
           (prog1 (viewsuppslast pl al depth cont) (backup ol)))
          (t (viewsuppsfail (car pl) al depth)))))

(defun viewsuppsunprovable (p pl al depth cont)
  (cond ((viewone (cadr p) (cdr p) al depth nil) (viewsuppsfail (car pl) al depth))
        (t (viewsuppslast pl al depth cont))))

(defun viewsuppsground (p pl al depth cont)
  (setq p (plug p al))
  (if (groundp p) (viewsuppsexit pl al depth cont)))

(defun viewsuppsnonground (p pl al depth cont)
  (setq p (plug p al))
  (if (groundp p) nil (viewsuppsexit pl al depth cont)))

(defun viewsuppsexecute (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (eval (cadr p))) (viewsuppsexit pl al depth cont))
                 (t (viewsuppsfail (car pl) al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))
           (prog1 (viewsuppsexit pl al depth cont) (backup ol)))
          (t (viewsuppsfail (car pl) al depth)))))

(defun viewsuppsevaluate (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((viewevals (cadr p)) (viewsuppsexit pl al depth cont))
                 (t (viewsuppsfail (car pl) al depth))))
          ((and (car (setq values (viewevals (cadr p))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al)))
           (prog1 (viewsuppsexit pl al depth cont) (backup ol)))
          (t (viewsuppsfail (car pl) al depth)))))

(defun viewsuppsstringmatch (p pl al depth cont)
  (viewsuppsexp `(execute (stringmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun viewsuppsbasicval (p pl al depth cont)
  (let (x y ol)
    (setq p (plug p al) x (butlast p) y (car (last p)))
    (cond ((not (groundp x)) (viewsuppsfail (car pl) al depth))
          ((setq ol (unify (funcall (get (car x) 'basicval) x) al y al))
           (prog1 (viewsuppslast pl al depth cont) (backup ol)))
          (t (viewsuppsfail (car pl) al depth)))))

(defun viewsuppsbasic (p pl al depth cont)
  (setq p (plug p al))
  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p))
              (viewsuppsexit pl al depth cont)))
        (t (viewsuppsfail (car pl) al depth))))

(defun viewsuppsrs (p pl al depth cont)
  (cond ((and *ancestry* (viewsuppsancestor p al cont)) (viewsuppsfail (car pl) al depth))
        ((and (numberp *ancestry*) (viewsuppsnumber p al cont 0))
         (setq *termination* t) (viewsuppsfail (car pl) al depth))
        ((viewsuppsdb p pl al depth cont *theory*))
        (t (viewsuppsfail (car pl) al depth))))

(defun viewsuppsancestor (p al cont)
  (do ((l cont (cdr l)))
      ((null l) nil)
      (if (identify (caaar l) (cadar l) p al) (return t))))

(defun viewsuppsnumber (p al cont n)
  (let (ol)
    (cond ((numgeqp n *ancestry*))
          ((null cont) nil)
          ((atom p)
           (viewsuppsnumber p al (cdr cont) (if (eq p (caaar cont)) (1+ n) n)))
          ((setq ol (unify p al (caaar cont) (cadar cont)))
           (prog1 (viewsuppsnumber p al (cdr cont) (1+ n)) (backup ol)))
          (t (viewsuppsnumber p al (cdr cont) n)))))

(defun viewsuppsdb (p pl al depth cont th)
  (viewsuppsth p pl al depth cont th)
  (do ((l (includees th) (cdr l)))
      ((null l))
      (viewsuppsdb p pl al depth cont (car l))))

(defun viewsuppsth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (viewsuppsexit pl al depth cont)
               (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))
            ((and (listp (car l)) (eq '<= (caar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (viewsupps (caddar l) (cddar l) bl
                        (1+ depth) (cons (list pl al depth) cont))
               (backup ol)))
            ((setq ol (unify (car l) bl p al))
             (viewsuppsexit pl al depth cont)
             (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun viewsuppsfail (p al depth)
  (let (ol)
    (viewfail p al depth)
    (when (setq ol (unify p al (car *residue*) truth)) 
      ;(format t "~&Deleting ~A from residue~%" (plugstdexp p al))
      (backup ol)
      (setq *residue* (cdr *residue*)))))

(defun viewsuppsexit (pl al depth cont)
  (let (p pplug)
    (setq p (car pl))
    (viewexit p al depth)
  ; when finished with a thing that *filter* okays, include it in the answers
  ; answers is a list of (ans . support)
  ; until we've finished with
    (when (funcall *filter* (if (atom p) p (car p)))
      (setq pplug (plugstdexp p al))
      (unless (eq (car *residue*) pplug)
	;(format t "~&Adding ~A to residue~%" pplug)
	(push pplug *residue*)))
    (cond ((cdr pl) (viewsupps (cadr pl) (cdr pl) al depth cont))
	  (cont (viewsuppsexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
	  (t (push (cons (plugstdexp *thing* alist) *residue*) *answers*)))
    (when (eq (car *residue*) pplug)
      ;(format t "~&Deleting ~A from residue~%" pplug)
      (setq *residue* (cdr *residue*)))
    (viewredo (car pl) al depth)))

(defun viewsuppslast (pl al depth cont)
  (viewexit (car pl) al depth)
  (when (funcall *filter* (if (atom (car pl)) (car pl) (caar pl)))
    (setq *answers* (cons (cons (plugstdexp (car pl) alist) (car *answers*)) (cdr *answers*))))
  (cond ((cdr pl) (viewsupps (cadr pl) (cdr pl) al depth cont))
        (cont (viewsuppsexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
        (t (setq *answers* (list* nil (cons (plugstdexp *thing* alist) (car *answers*)) (cdr *answers*))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; nextfindp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun nextfindp (p th &optional (*filter* #'failure))
  (nextfindx 't p th))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; nextfindx
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun nextfindx (*thing* p *theory* &optional (*filter* #'failure))
  (let (alist *answer*)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq alist (environment))
    (when (nextone p (list p) alist 0 nil) *answer*)))

(defun nextone (p pl al depth cont)
  (setq *inferences* (1+ *inferences*))
  (nextcall p al depth)
  (cond ((>= *inferences* *limit*) (setq *termination* t) (nextstop (car pl) al depth))
        ((>= depth *depth*) (setq *termination* t) (nextstop (car pl) al depth))
        (t (nextoneexp p pl al depth cont))))

(defun nextoneexp (p pl al depth cont)
  (cond ((atom p) (nextoneconstant p pl al depth cont))
        ((eq (car p) 'not) (nextoneunprovable p pl al depth cont))
        ((eq (car p) 'and) (nextoneand p pl al depth cont))
        ((eq (car p) 'or) (nextoneor p pl al depth cont))
        ((eq (car p) 'same) (nextonesame p pl al depth cont))
        ((eq (car p) 'distinct) (nextonedistinct p pl al depth cont))
        ((and *attachments* (eq (car p) 'oneof)) (nextoneoneof p pl al depth cont))
        ((and *attachments* (eq (car p) 'choose)) (nextonechoose p pl al depth cont))
        ((and *attachments* (eq (car p) 'bagofall)) (nextonebagofall p pl al depth cont))
        ((and *attachments* (eq (car p) 'unprovable)) (nextoneunprovable p pl al depth cont))
	((and *attachments* (eq (car p) 'ground)) (nextoneground p pl al depth cont))
	((and *attachments* (eq (car p) 'nonground)) (nextonenonground p pl al depth cont))
        ((and *attachments* (eq (car p) 'execute)) (nextoneexecute p pl al depth cont))
        ((and *attachments* (eq (car p) 'evaluate)) (nextoneevaluate p pl al depth cont))
        ((and *attachments* (eq (car p) 'stringmatch)) (nextonestringmatch p pl al depth cont))
	((and *attachments* (get (car p) 'basicval)) (nextonebasicval p pl al depth cont))
        ((and *attachments* (get (car p) 'basic)) (nextonebasic p pl al depth cont))
        ((funcall *filter* (car p)) (nextoneknownrs p pl al depth cont))
        (t (nextoners p pl al depth cont))))

(defun nextoneconstant (p pl al depth cont)
  (cond ((eq p 'true) (nextonelast pl al depth cont))
        ((eq p 'false) (nextfail (car pl) al depth))
        (t (nextoners p pl al depth cont))))

(defun nextoneand (p pl al depth cont)
  (cond ((null (cdr p)) (nextonelast pl al depth cont))
        ((nextone (cadr p) (cdr p) al depth (cons (list pl al depth) cont)))
        (t (nextfail (car pl) al depth))))

(defun nextoneor (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (nextfail (car pl) al depth))
      (when (nextone (car l) (list (car l)) al depth cont)
        (return t))))

(defun nextonesame (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (prog1 (nextonelast pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextonedistinct (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (backup ol) (nextfail (car pl) al depth))
          (t (nextonelast pl al depth cont)))))

(defun nextoneoneof (p pl al depth cont)
  (when (seqvarp (caddr p)) (setq p (plug p al)))
  (do ((l (cddr p) (cdr l)) (ol))
      ((null l) (nextfail (car pl) al depth))
      (cond ((not (setq ol (unify (cadr p) al (car l) al))))
            ((nextoneexit pl al depth cont) (backup ol) (return t))
            (t (backup ol)))))

(defun nextonechoose (p pl al depth cont)
  (let (x ol)
    (setq p (plugstdexp p al))
    (setq x (nextfindx (cadr p) (caddr p) *theory*))
    (cond ((and (not (null x)) (setq ol (unify (cadddr p) alist x alist)))
           (prog1 (nextonelast pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextonebagofall (p pl al depth cont)
  (let (answer ol)
    (setq p (plug p al))
    (setq answer (cons 'listof (nextfinds (cadr p) (caddr p) *theory*)))
    (cond ((setq ol (unify answer al (cadddr p) al))
           (prog1 (nextonelast pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextoneunprovable (p pl al depth cont)
  (cond ((nextone (cadr p) (cdr p) al depth nil) (nextfail (car pl) al depth))
        (t (nextonelast pl al depth cont))))

(defun nextoneground (p pl al depth cont)
  (cond ((and (groundp (plug (cadr p) al))) (nextonelast pl al depth cont))
        (t (nextfail (car pl) al depth))))

(defun nextonenonground (p pl al depth cont)
  (cond ((groundp (plug (cadr p) al)) (nextfail (car pl) al depth))
        (t (nextonelast pl al depth cont))))

(defun nextoneexecute (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (eval (cadr p)))
                  (nextonelast pl al depth cont))
                 (t (nextfail (car pl) al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))
           (prog1 (nextonelast pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextoneevaluate (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((viewevals (cadr p)) (nextonelast pl al depth cont))
                 (t (nextfail (car pl) al depth))))
          ((and (car (setq values (viewevals (cadr p))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al)))
           (prog1 (nextonelast pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextonestringmatch (p pl al depth cont)
  (nextoneexp `(execute (stringmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun nextonebasicval (p pl al depth cont)
  (let (x y ol)
    (setq p (plug p al) x (butlast p) y (car (last p)))
    (cond ((not (groundp x)) (nextfail (car pl) al depth))
          ((setq ol (unify (funcall (get (car x) 'basicval) x) al y al))
           (prog1 (nextonelast pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextonebasic (p pl al depth cont)
  (setq p (plug p al))
  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p)))
         (nextonelast pl al depth cont))
        (t (nextfail (car pl) al depth))))

(defun nextoners (p pl al depth cont)
  (cond ((and *ancestry* (nextoneancestor p al cont)) (nextfail (car pl) al depth))
        ((nextonedb p pl al depth cont *theory*))
        (t (nextfail (car pl) al depth))))

(defun nextoneancestor (p al cont)
  (do ((l (cdr cont) (cdr l)))
      ((null l) nil)
      (if (identify (caaar l) (cadar l) p al) (return t))))

(defun nextonedb (p pl al depth cont th)
  (cond ((nextoneth p pl al depth cont th))
        (t (do ((l (includees th) (cdr l)))
               ((null l) nil)
               (when (nextonedb p pl al depth cont (car l)) (return t))))))

(defun nextoneth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))
             (cond ((not (setq ol (unify (cadar l) bl p al))))
                   ((nextoneexit pl al depth cont) (backup ol) (return t))
                   ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol))))
            ((and (listp (car l)) (eq '<= (caar l)))
             (cond ((not (setq ol (unify (cadar l) bl p al))))
                   ((nextone (caddar l) (cddar l) bl
                             (1+ depth) (cons (list pl al depth) cont))
                    (backup ol) (return  t))
                   (t (backup ol))))
            ((setq ol (unify (car l) bl p al))
             (cond ((nextoneexit pl al depth cont) (backup ol) (return t))
                   ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun nextoneknownrs (p pl al depth cont)
  (cond ((nextoneknowndb p pl al depth cont *theory*))
        (t (nextfail (car pl) al depth))))

(defun nextoneknowndb (p pl al depth cont th)
  (nextoneknownth p pl al depth cont th)
  (do ((l (includees th) (cdr l)))
      ((null l))
      (nextoneknowndb p pl al depth cont (car l))))

(defun nextoneknownth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((setq ol (unify (car l) bl p al))
             (unless (nextoneunknowndb p al *theory*)
               (nextoneexit pl al depth cont))
             (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol))))
            ((and (listp (car l)) (eq (caar l) 'pos)
                  (setq ol (unify (cadar l) bl p al)))
             (nextoneexit pl al depth cont)
             (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun nextoneunknowndb (p al th)
  (cond ((nextoneunknownth p al th))
        (t (do ((l (includees th) (cdr l)))
               ((null l) nil)
               (when (nextoneunknowndb p al (car l)) (return t))))))

(defun nextoneunknownth (p al th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (when (and (listp (car l)) (eq (caar l) 'neg)
                 (setq ol (unify p al (cadar l) bl)))
        (backup ol) (return t))))

(defun nextoneexit (pl al depth cont)
  (let (ans)
    (nextexit (car pl) al depth)
    (cond ((cdr pl) (setq ans (nextone (cadr pl) (cdr pl) al depth cont)))
          (cont (setq ans (nextoneexit (caar cont) (cadar cont) (caddar cont) (cdr cont))))
          (t (setq *answer* (plugstdexp *thing* alist) ans t)))
    (if ans t (nextredo (car pl) al depth))))

(defun nextonelast (pl al depth cont)
  (nextexit (car pl) al depth)
  (cond ((cdr pl) (nextone (cadr pl) (cdr pl) al depth cont))
        (cont (nextoneexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
        (t (setq *answer* (plugstdexp *thing* alist)))))

(defun nextcall (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Call: | p) nil)))

(defun nextexit (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Exit: | p) nil)))

(defun nextredo (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Redo: | p) nil)))

(defun nextfail (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Fail: | p) nil)))

(defun nextstop (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Stop: | p) nil)))

(defun nextsave (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Save: | p) nil)))

(defun nextdrop (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Drop: | p) nil)))

(defun nextdone (p al depth)
  (cond ((not traceexpressions) nil)
        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)
         (tracemessage depth '|Done: | p) nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; nextfinds
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun nextfinds (*thing* p *theory* &optional (*filter* #'failure))
  (let (alist *answers*)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq alist (environment))
    (nextall p (list p) alist 0 nil)
    (nreverse (uniquify *answers*))))

(defun nextall (p pl al depth cont)
  (setq *inferences* (1+ *inferences*))
  (nextcall p al depth)
  (cond ((>= *inferences* *limit*) (setq *termination* t) (nextstop (car pl) al depth))
        ((>= depth *depth*) (setq *termination* t) (nextstop (car pl) al depth))
        (t (nextallexp p pl al depth cont))))

(defun nextallexp (p pl al depth cont)
  (cond ((atom p) (nextallconstant p pl al depth cont))
        ((eq (car p) 'not) (nextallunprovable p pl al depth cont))
        ((eq (car p) 'and) (nextalland p pl al depth cont))
        ((eq (car p) 'or) (nextallor p pl al depth cont))
        ((eq (car p) 'same) (nextallsame p pl al depth cont))
        ((eq (car p) 'distinct) (nextalldistinct p pl al depth cont))
        ((and *attachments* (eq (car p) 'oneof)) (nextalloneof p pl al depth cont))
        ((and *attachments* (eq (car p) 'choose)) (nextallchoose p pl al depth cont))
        ((and *attachments* (eq (car p) 'bagofall)) (nextallbagofall p pl al depth cont))
        ((and *attachments* (eq (car p) 'unprovable)) (nextallunprovable p pl al depth cont))
	((and *attachments* (eq (car p) 'ground)) (nextallground p pl al depth cont))
	((and *attachments* (eq (car p) 'nonground)) (nextallnonground p pl al depth cont))
        ((and *attachments* (eq (car p) 'execute)) (nextallexecute p pl al depth cont))
        ((and *attachments* (eq (car p) 'evaluate)) (nextallevaluate p pl al depth cont))
        ((and *attachments* (eq (car p) 'stringmatch)) (nextallstringmatch p pl al depth cont))
	((and *attachments* (get (car p) 'basicval)) (nextallbasicval p pl al depth cont))
        ((and *attachments* (get (car p) 'basic)) (nextallbasic p pl al depth cont))
        ((funcall *filter* (car p)) (nextallknownrs p pl al depth cont))
        (t (nextallrs p pl al depth cont))))

(defun nextallconstant (p pl al depth cont)
  (cond ((eq p 'true) (nextalllast pl al depth cont))
        ((eq p 'false) (nextfail (car pl) al depth))
        (t (nextallrs p pl al depth cont))))

(defun nextalland (p pl al depth cont)
  (cond ((null (cdr p)) (nextalllast pl al depth cont))
        ((nextall (cadr p) (cdr p) al depth (cons (list pl al depth) cont)))
        (t (nextfail (car pl) al depth))))

(defun nextallor (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (nextfail (car pl) al depth))
      (nextall (car l) (list (car l)) al depth cont)))

(defun nextallsame (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (nextalllast pl al depth cont)
           (backup ol))
          (t (nextfail p al depth)))))

(defun nextalldistinct (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (backup ol) (nextfail p al depth))
          (t (nextalllast pl al depth cont)))))

(defun nextalloneof (p pl al depth cont)
  (when (seqvarp (caddr p)) (setq p (plug p al)))
  (do ((l (cddr p) (cdr l)) (ol))
      ((null l) (nextfail (car pl) al depth))
      (when (setq ol (unify (cadr p) al (car l) al))
        (nextallexit pl al depth cont)
        (backup ol))))

(defun nextallchoose (p pl al depth cont)
  (let (x ol)
    (setq p (plugstdexp p al))
    (setq x (nextfindx (cadr p) (caddr p) *theory*))
    (cond ((and (not (null x)) (setq ol (unify (cadddr p) alist x alist)))
           (prog1 (nextallexit pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextallbagofall (p pl al depth cont)
  (let (answer ol)
    (setq p (plug p al))
    (setq answer (cons 'listof (nextfinds (cadr p) (caddr p) *theory*)))
    (cond ((setq ol (unify answer al (cadddr p) al))
           (prog1 (nextalllast pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextallunprovable (p pl al depth cont)
  (cond ((nextone (cadr p) (cdr p) al depth nil) (nextfail (car pl) al depth))
        (t (nextalllast pl al depth cont))))

(defun nextallground (p pl al depth cont)
  (setq p (plug p al))
  (if (groundp p) (nextallexit pl al depth cont)))

(defun nextallnonground (p pl al depth cont)
  (setq p (plug p al))
  (if (groundp p) nil (nextallexit pl al depth cont)))

(defun nextallexecute (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (eval (cadr p))) (nextallexit pl al depth cont))
                 (t (nextfail (car pl) al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))
           (prog1 (nextallexit pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextallevaluate (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (apply (caadr p) (cdadr p))) (nextallexit pl al depth cont))
                 (t (nextfail (car pl) al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (apply (caadr p) (cdadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al)))
           (prog1 (nextallexit pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextallstringmatch (p pl al depth cont)
  (nextallexp `(execute (stringmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun nextallbasicval (p pl al depth cont)
  (let (x y ol)
    (setq p (plug p al) x (butlast p) y (car (last p)))
        (cond ((not (groundp x)) (nextfail (car pl) al depth))
          ((setq ol (unify (funcall (get (car x) 'basicval) x) al y al))
           (prog1 (nextalllast pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))

(defun nextallbasic (p pl al depth cont)
  (setq p (plug p al))
  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p))
              (nextallexit pl al depth cont)))
        (t (nextfail (car pl) al depth))))

(defun nextallrs (p pl al depth cont)
  (cond ((and *ancestry* (nextallancestor p al cont)) (nextfail (car pl) al depth))
        ((and (numberp *ancestry*) (nextallnumber p al cont 0))
         (setq *termination* t) (nextfail (car pl) al depth))
        ((nextalldb p pl al depth cont *theory*))
        (t (nextfail (car pl) al depth))))

(defun nextallancestor (p al cont)
  (do ((l cont (cdr l)))
      ((null l) nil)
      (if (identify (caaar l) (cadar l) p al) (return t))))

(defun nextallnumber (p al cont n)
  (let (ol)
    (cond ((numgeqp n *ancestry*))
          ((null cont) nil)
          ((atom p)
           (nextallnumber p al (cdr cont) (if (eq p (caaar cont)) (1+ n) n)))
          ((setq ol (unify p al (caaar cont) (cadar cont)))
           (prog1 (nextallnumber p al (cdr cont) (1+ n)) (backup ol)))
          (t (nextallnumber p al (cdr cont) n)))))

(defun nextalldb (p pl al depth cont th)
  (nextallth p pl al depth cont th)
  (do ((l (includees th) (cdr l)))
      ((null l))
      (nextalldb p pl al depth cont (car l))))

(defun nextallth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (nextallexit pl al depth cont)
               (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))
            ((and (listp (car l)) (eq '<= (caar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (nextall (caddar l) (cddar l) bl
                        (1+ depth) (cons (list pl al depth) cont))
               (backup ol)))
            ((setq ol (unify (car l) bl p al))
             (nextallexit pl al depth cont)
             (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun nextallknownrs (p pl al depth cont)
  (cond ((nextallknowndb p pl al depth cont *theory*))
        (t (nextfail (car pl) al depth))))

(defun nextallknowndb (p pl al depth cont th)
  (nextallknownth p pl al depth cont th)
  (do ((l (includees th) (cdr l)))
      ((null l))
      (nextallknowndb p pl al depth cont (car l))))

(defun nextallknownth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((setq ol (unify (car l) bl p al))
             (unless (nextoneunknowndb p al *theory*)
               (nextallexit pl al depth cont))
             (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol))))
            ((and (listp (car l)) (eq (caar l) 'pos)
                  (setq ol (unify (cadar l) bl p al)))
             (nextallexit pl al depth cont)
             (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun nextallunknowndb (p al th)
  (cond ((nextallunknownth p al th))
        (t (do ((l (includees th) (cdr l)))
               ((null l) nil)
               (when (nextallunknowndb p al (car l)) (return t))))))

(defun nextallunknownth (p al th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (when (and (listp (car l)) (eq (caar l) 'neg)
                 (setq ol (unify p al (cadar l) bl)))
        (backup ol) (return t))))

(defun nextallexit (pl al depth cont)
  (nextexit (car pl) al depth)
  (cond ((cdr pl) (nextall (cadr pl) (cdr pl) al depth cont))
        (cont (nextallexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
        (t (setq *answers* (cons (plugstdexp *thing* alist) *answers*))))
  (nextredo (car pl) al depth))

(defun nextalllast (pl al depth cont)
  (nextexit (car pl) al depth)
  (cond ((cdr pl) (nextall (cadr pl) (cdr pl) al depth cont))
        (cont (nextallexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
        (t (setq *answers* (cons (plugstdexp *thing* alist) *answers*)) nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; viewresidue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun viewresidue (p *theory* &optional (*filter* #'basep))
  (let (alist *residue* *answer* tracecalls)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq alist (environment))
    (setq *variables* p)
    (when (viewresiduedepth p (list p) alist 0 nil) *answer*)))

(defun viewresiduedepth (p pl al depth cont)
  (setq *inferences* (1+ *inferences*))
  (viewcall p al depth)
  (cond ((>= *inferences* *limit*) (setq *termination* t) (viewstop (car pl) al depth))
        ((>= depth *depth*) (setq *termination* t) (viewstop (car pl) al depth))
        (t (viewresidueexp p pl al depth cont))))

(defun viewresidueexp (p pl al depth cont)
  (cond ((atom p) (viewresidueconstant p pl al depth cont))
        ((eq 'not (car p)) (viewresidueunprovable p pl al depth cont))
        ((eq 'and (car p)) (viewresidueand p pl al depth cont))
        ((eq 'or (car p)) (viewresidueor p pl al depth cont))
        ((eq 'same (car p)) (viewresiduesame p pl al depth cont))
        ((eq 'distinct (car p)) (viewresiduedistinct p pl al depth cont))
        ((and *attachments* (eq 'oneof (car p))) (viewresidueassumption p pl al depth cont))
        ((and *attachments* (eq 'choose (car p))) (viewresiduechoose p pl al depth cont))
        ((and *attachments* (eq 'bagofall (car p))) (viewresiduebagofall p pl al depth cont))
        ((and *attachments* (eq 'unprovable (car p))) (viewresidueunprovable p pl al depth cont))
	((and *attachments* (eq 'ground (car p))) (viewresidueground p pl al depth cont))
	((and *attachments* (eq 'nonground (car p))) (viewresiduenonground p pl al depth cont))
        ((and *attachments* (eq 'execute (car p))) (viewresidueexecute p pl al depth cont))
        ((and *attachments* (eq 'evaluate (car p))) (viewresidueevaluate p pl al depth cont))
        ((and *attachments* (eq 'stringmatch (car p))) (viewresiduestringmatch p pl al depth cont))
	((and *attachments* (get (car p) 'basicval)) (viewresiduebasicval p pl al depth cont))
        ((and *attachments* (get (car p) 'basic)) (viewresiduebasic p pl al depth cont))
        ((funcall *filter* (operator p)) (viewresidueassumption p pl al depth cont))
        (t (viewresiduers p pl al depth cont))))

(defun viewresidueconstant (p pl al depth cont)
  (cond ((eq 'true p) (viewresiduelast pl al depth cont))
        ((eq 'false p) (viewfail (car pl) al depth))
        ((funcall *filter* p) (viewresidueassumption p pl al depth cont))
        (t (viewresiduers p pl al depth cont))))

(defun viewresidueand (p pl al depth cont)
  (cond ((null (cdr p)) (viewresiduelast pl al depth cont))
        ((viewresiduedepth (cadr p) (cdr p) al depth (cons (list pl al depth) cont)))
        (t (viewfail (car pl) al depth))))

(defun viewresidueor (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (viewfail (car pl) al depth))
      (when (viewresiduedepth (car l) (list (car l)) al depth cont)
        (return t))))

(defun viewresiduesame (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (prog1 (viewresiduelast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewresiduedistinct (p pl al depth cont)
  (let (x y)
    (cond ((and (setq x (groundplugstdexp (cadr p) al))
                (setq y (groundplugstdexp (caddr p) al)))
           (cond ((equal x y) (viewfail (car pl) al depth))
                 (t (viewresiduelast pl al depth cont))))
          (t (viewresidueassumption p pl al depth cont)))))

(defun viewresidueoneof (p pl al depth cont)
  (when (seqvarp (caddr p)) (setq p (plug p al)))
  (do ((l (cddr p) (cdr l)) (ol))
      ((null l) (viewfail (car pl) al depth))
      (cond ((not (setq ol (unify (cadr p) al (car l) al))))
            ((viewresidueexit pl al depth cont) (backup ol) (return t))
            (t (backup ol)))))

(defun viewresiduechoose (p pl al depth cont)
  (let ((*residue* (cons p *residue*))) (viewresiduelast pl al depth cont)))

(defun viewresiduebagofall (p pl al depth cont)
  (let (residue)
    (setq p (plugstdexp p al))
    (setq residue (maksor (viewresidues (caddr p) *theory* *filter*)))
    (let ((*residue* (cons `(bagofall ,(cadr p) ,residue ,(cadddr p)) *residue*)))
      (viewresiduelast pl al depth cont))))

(defun viewresidueunprovable (p pl al depth cont)
  (let (residue)
    (setq p (plugstdexp (cadr p) al))
    (setq residue (maksor (viewresidues p *theory* *filter*)))
    (do ((l (let (alist) (demorgantrick (cnfs residue))) (cdr l)))
        ((null l) (viewfail (cadr pl) al depth))
        (let ((*residue* (nreconc (car l) *residue*)))
          (when (viewresiduelast pl al depth cont) (return t))))))

(defun viewresiduebasicval (p pl al depth cont)
  (let (x y ol)
    (setq x (butlast p) y (car (last p)))
    (cond ((setq x (groundplugstdexp x al))
           (setq x (funcall (get (car x) 'basicval) x))
           (if (and (not (null x)) (setq ol (unify y al x al)))
             (prog1 (viewresiduelast pl al depth cont) (backup ol))
             (viewfail (car pl) al depth)))
          (t (viewresidueassumption p pl al depth cont)))))

(defun viewresidueground (p pl al depth cont)
  (cond ((and (groundp (plug (cadr p) al))) (viewresiduelast pl al depth cont))
        (t (viewfail (car pl) al depth))))

(defun viewresiduenonground (p pl al depth cont)
  (cond ((groundp (plug (cadr p) al)) (viewfail (car pl) al depth))
        (t (viewresiduelast pl al depth cont))))

(defun viewresidueexecute (p pl al depth cont)
  (setq p (plugstdexp p al))
  (let ((*residue* (cons p *residue*))) (viewresiduelast pl al depth cont)))

(defun viewresidueevaluate (p pl al depth cont)
  (setq p (plugstdexp p al))
  (let ((*residue* (cons p *residue*))) (viewresiduelast pl al depth cont)))

(defun viewresiduestringmatch (p pl al depth cont)
  (viewresidueexp `(execute (stringmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun viewresiduebasic (p pl al depth cont)
  (setq p (plug p al))
  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p)))
         (viewresiduelast pl al depth cont))
        (t (viewfail (car pl) al depth))))

(defun viewresidueassumption (p pl al depth cont)
  (setq p (plugstdexp p al))
  (cond ((find p *residue* :test #'equalp) (viewresiduelast pl al depth cont))
        ((or (not *consistency*)
             (not (or (rebuttalp p *residue*) (rebuttheoryp p *theory*)))
             (consistentp p *residue*))
         (let ((*residue* (cons p *residue*))) (viewresiduelast pl al depth cont)))
        (t  (viewfail (car pl) al depth))))

(defun viewresiduers (p pl al depth cont)
  (cond ((and *ancestry* (viewresidueancestor p al cont)) (viewfail (car pl) al depth))
        ((viewresiduedb p pl al depth cont *theory*))
        (t (viewfail (car pl) al depth))))

(defun viewresidueancestor (p al cont)
  (do ((l cont (cdr l)))
      ((null l) nil)
      (when (identify (caaar l) (cadar l) p al) (return t))))

(defun viewresiduedb (p pl al depth cont th)
  (cond ((viewresidueth p pl al depth cont th))
        (t (do ((l (includees th) (cdr l)))
               ((null l) nil)
               (when (viewresiduedb p pl al depth cont (car l)) (return t))))))

(defun viewresidueth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))
             (cond ((not (setq ol (unify (cadar l) bl p al))))
                   ((viewresidueexit pl al depth cont)
                    (backup ol)
                    (return t))
                   ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol))))
            ((and (listp (car l)) (eq '<= (caar l)))
             (cond ((not (setq ol (unify (cadar l) bl p al))))
                   ((viewresiduedepth (caddar l) (cddar l) bl
                                      (1+ depth) (cons (list pl al depth) cont))
                    (backup ol) (return  t))
                   (t (backup ol))))
            ((setq ol (unify (car l) bl p al))
             (cond ((viewresidueexit pl al depth cont)
                    (backup ol)
                    (return t))
                   ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun viewresidueexit (pl al depth cont)
  (let (dum ans)
    (viewexit (car pl) al depth)
    (cond ((cdr pl) (setq ans (viewresiduedepth (cadr pl) (cdr pl) al depth cont)))
          (cont (setq ans (viewresidueexit (caar cont) (cadar cont) (caddar cont) (cdr cont))))
          (t (setq ans (plugstdexp (reverse *residue*) alist))
             (dolist (var *variables*)
               (unless (eq (setq dum (plugstdexp var alist)) var)
                 (setq ans (cons `(same ,var ,dum) ans))))
             (setq *answer* (maksand ans) ans t)))
    (if ans t (viewredo (car pl) al depth))))

(defun viewresiduelast (pl al depth cont)
  (let (dum ans)
    (viewexit (car pl) al depth)
    (cond ((cdr pl) (viewresiduedepth (cadr pl) (cdr pl) al depth cont))
          (cont (viewresidueexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
          (t (setq ans (plugstdexp (reverse *residue*) alist))
             (dolist (var *variables*)
               (unless (eq (setq dum (plugstdexp var alist)) var)
                 (setq ans (cons `(same ,var ,dum) ans))))
             (setq *answer* (maksand ans)) t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; viewresidues
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun viewresidues (p *theory* &optional (*filter* #'basep))
  (let (alist *variables* *residue* *answers* tracecalls)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq alist (environment))
    (setq *variables* p)
    (viewresiduesdepth p (list p) alist 0 nil)
    (nreverse *answers*)))

(defun viewresiduesdepth (p pl al depth cont)
  (setq *inferences* (1+ *inferences*))
  (viewcall p al depth)
  (cond ((>= *inferences* *limit*) (setq *termination* t) (viewstop (car pl) al depth))
        ((>= depth *depth*) (setq *termination* t) (viewstop (car pl) al depth))
        (t (viewresiduesexp p pl al depth cont))))

(defun viewresiduesexp (p pl al depth cont)
  (cond ((atom p) (viewresiduesconstant p pl al depth cont))
        ((eq (car p) 'not) (viewresiduesunprovable p pl al depth cont))
        ((eq (car p) 'and) (viewresiduesand p pl al depth cont))
        ((eq (car p) 'or) (viewresiduesor p pl al depth cont))
        ((eq (car p) 'same) (viewresiduessame p pl al depth cont))
        ((eq (car p) 'distinct) (viewresiduesdistinct p pl al depth cont))
        ((and *attachments* (eq (car p) 'oneof)) (viewresiduesassumption p pl al depth cont))
        ((and *attachments* (eq (car p) 'choose)) (viewresidueschoose p pl al depth cont))
        ((and *attachments* (eq (car p) 'bagofall)) (viewresiduesbagofall p pl al depth cont))
        ((and *attachments* (eq (car p) 'unprovable)) (viewresiduesunprovable p pl al depth cont))
	((and *attachments* (eq (car p) 'ground)) (viewresiduesground p pl al depth cont))
	((and *attachments* (eq (car p) 'nonground)) (viewresiduesnonground p pl al depth cont))
        ((and *attachments* (eq (car p) 'execute)) (viewresiduesexecute p pl al depth cont))
        ((and *attachments* (eq (car p) 'evaluate)) (viewresiduesevaluate p pl al depth cont))
        ((and *attachments* (eq (car p) 'stringmatch)) (viewresiduesstringmatch p pl al depth cont))
	((and *attachments* (get (car p) 'basicval)) (viewresiduesbasicval p pl al depth cont))
        ((and *attachments* (get (car p) 'basic)) (viewresiduesbasic p pl al depth cont))
        ((funcall *filter* (car p)) (viewresiduesassumption p pl al depth cont))
        (t (viewresiduesrs p pl al depth cont))))

(defun viewresiduesconstant (p pl al depth cont)
  (cond ((eq p 'true) (viewresidueslast pl al depth cont))
        ((eq p 'false) (viewfail (car pl) al depth))
        ((funcall *filter* p) (viewresiduesassumption p pl al depth cont))
        (t (viewresiduesrs p pl al depth cont))))

(defun viewresiduesand (p pl al depth cont)
  (cond ((null (cdr p)) (viewresidueslast pl al depth cont))
        ((viewresiduesdepth (cadr p) (cdr p) al depth (cons (list pl al depth) cont)))
        (t (viewfail (car pl) al depth))))

(defun viewresiduesor (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (viewfail (car pl) al depth))
      (when (viewresiduesdepth (car l) (list (car l)) al depth cont))))

(defun viewresiduessame (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (prog1 (viewresidueslast pl al depth cont) (backup ol)))
          (t (viewfail (car pl) al depth)))))

(defun viewresiduesdistinct (p pl al depth cont)
  (let (x y)
    (cond ((and (setq x (groundplugstdexp (cadr p) al))
                (setq y (groundplugstdexp (caddr p) al)))
           (cond ((equal x y) (viewfail (car pl) al depth))
                 (t (viewresidueslast pl al depth cont))))
          (t (viewresiduesassumption p pl al depth cont)))))

(defun viewresiduesoneof (p pl al depth cont)
  (when (seqvarp (caddr p)) (setq p (plug p al)))
  (do ((l (cddr p) (cdr l)) (ol))
      ((null l) (viewfail (car pl) al depth))
      (when (setq ol (unify (cadr p) al (car l) al))
        (viewresiduesexit pl al depth cont)
        (backup ol))))

(defun viewresidueschoose (p pl al depth cont)
  (let ((*residue* (cons p *residue*))) (viewresidueslast pl al depth cont)))

#|
(defun viewresiduesbagofall (p pl al depth cont)
  (let (answer ol)
    (setq p (plug p al))
    (setq answer (cons 'listof (nextfinds (cadr p) (caddr p) *theory*)))
    (cond ((setq ol (unify answer al (cadddr p) al))
           (prog1 (nextalllast pl al depth cont) (backup ol)))
          (t (nextfail (car pl) al depth)))))
|#


(defun viewresiduesbagofall (p pl al depth cont)
  (let (residue)
    (setq p (plugstdexp p al))
    (setq residue (maksor (viewresidues (caddr p) *theory* *filter*)))
    (let ((*residue* (cons `(bagofall ,(cadr p) ,residue ,(cadddr p)) *residue*)))
          (viewresidueslast pl al depth cont))))

(defun viewresiduesunprovable (p pl al depth cont)
  (let (residue)
    (setq p (plugstdexp (cadr p) al))
    (setq residue (maksor (viewresidues p *theory* *filter*)))
    (do ((l (let (alist) (demorgantrick (cnfs residue))) (cdr l)))
        ((null l) (viewfail (car pl) al depth))
        (let ((*residue* (nreconc (car l) *residue*)))
          (viewresiduesexit pl al depth cont)))))

(defun viewresiduesground (p pl al depth cont)
  (cond ((and (groundp (plug (cadr p) al))) (viewresidueslast pl al depth cont))
        (t (viewfail (car pl) al depth))))

(defun viewresiduesnonground (p pl al depth cont)
  (cond ((groundp (plug (cadr p) al)) (viewfail (car pl) al depth))
        (t (viewresidueslast pl al depth cont))))

(defun viewresiduesexecute (p pl al depth cont)
  (setq p (plugstdexp p al))
  (let ((*residue* (cons p *residue*))) (viewresidueslast pl al depth cont)))

(defun viewresiduesevaluate (p pl al depth cont)
  (setq p (plugstdexp p al))
  (let ((*residue* (cons p *residue*))) (viewresidueslast pl al depth cont)))

(defun viewresiduesstringmatch (p pl al depth cont)
  (viewresiduesexp `(execute (stringmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun viewresiduesbasicval (p pl al depth cont)
  (let (x y ol)
    (setq x (butlast p) y (car (last p)))
    (cond ((setq x (groundplugstdexp x al))
           (setq x (funcall (get (car x) 'basicval) x))
           (if (and (not (null x)) (setq ol (unify y al x al)))
             (prog1 (viewresidueslast pl al depth cont) (backup ol))
             (viewfail (car pl) al depth)))
          (t (viewresiduesassumption p pl al depth cont)))))

(defun viewresiduesbasic (p pl al depth cont)
  (setq p (plugstdexp p al))
  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p)))
         (viewresidueslast pl al depth cont))
        (t (let ((*residue* (cons p *residue*))) (viewresidueslast pl al depth cont)))))

(defun viewresiduesassumption (p pl al depth cont)
  (setq p (plugstdexp p al))
  (cond ((find p *residue* :test #'equalp) (viewresidueslast pl al depth cont))
        ((or (not *consistency*)
             (not (or (rebuttalp p *residue*) (rebuttheoryp p *theory*)))
             (consistentp p *residue*))
         (let ((*residue* (cons p *residue*))) (viewresidueslast pl al depth cont)))
        (t  (viewfail (car pl) al depth))))

(defun viewresiduesrs (p pl al depth cont)
  (cond ((and *ancestry* (viewresiduesancestor p al cont)) (viewfail (car pl) al depth))
        ((and (numberp *ancestry*) (viewresiduesnumber p al cont 0))
         (viewresiduesassumption p pl al depth cont))
        ((viewresiduesdb p pl al depth cont *theory*))
        (t (viewfail (car pl) al depth))))

(defun viewresiduesancestor (p al cont)
  (do ((l cont (cdr l)))
      ((null l) nil)
      (if (identify (caaar l) (cadar l) p al) (return t))))

(defun viewresiduesnumber (p al cont n)
  (cond ((numgeqp n *ancestry*))
        ((null cont) nil)
        ((atom p)
         (viewresiduesnumber p al (cdr cont) (if (eq p (caaar cont)) (1+ n) n)))
        ;((setq ol (unify p al (caaar cont) (cadar cont)))
        ; (prog1 (viewresiduesnumber p al (cdr cont) (1+ n)) (backup ol)))
        ((eq (operator p) (operator (caaar cont)))
         (viewresiduesnumber p al (cdr cont) (1+ n)))
        (t (viewresiduesnumber p al (cdr cont) n))))

(defun viewresiduesdb (p pl al depth cont th)
  (viewresiduesth p pl al depth cont th)
  (do ((l (includees th) (cdr l)))
      ((null l) nil)
      (viewresiduesdb p pl al depth cont (car l))))

(defun viewresiduesth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (viewresiduesexit pl al depth cont)
               (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))
            ((and (listp (car l)) (eq '<= (caar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (viewresiduesdepth (caddar l) (cddar l) bl
                                  (1+ depth) (cons (list pl al depth) cont))
               (backup ol)))
            ((setq ol (unify (car l) bl p al))
             (viewresiduesexit pl al depth cont)
             (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

#|
(defun viewresiduesexit (pl al depth cont)
  (let (dum ans)
    (viewexit (car pl) al depth)
    (cond ((cdr pl) (viewresiduesdepth (cadr pl) (cdr pl) al depth cont))
          (cont (viewresiduesexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
          (t (setq ans (plugstdexp (reverse *residue*) alist))
             (setq dum (plugstdexp *variables* alist))
             (unless (equalp *variables* dum)
               (setq ans (cons `(same ,*variables* ,dum) ans)))
             ;(dolist (var *variables*)
             ;  (setq dum (plugstdexp var alist)) (print dum)
             ;   (setq ans (cons `(same ,var ,dum) ans)))
             ;(print ans)
             (setq *answers* (adjoin (maksand ans) *answers* :test #'equalp))))
    (viewredo (car pl) al depth)))
|#

(defun viewresiduesexit (pl al depth cont)
  (let (dum ans)
    (viewexit (car pl) al depth)
    (cond ((cdr pl) (viewresiduesdepth (cadr pl) (cdr pl) al depth cont))
          (cont (viewresiduesexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
          (t (setq ans (plugstdexp (reverse *residue*) alist))
             (setq dum (plugstdexp *variables* alist))
             (unless (equalp *variables* dum)
               (setq ans (nreconc (unroll *variables* dum) ans)))
             ;(dolist (var *variables*)
             ;  (setq dum (plugstdexp var alist)) (print dum)
             ;   (setq ans (cons `(same ,var ,dum) ans)))
             ;(print ans)
             (setq *answers* (adjoin (maksand ans) *answers* :test #'equalp))))
    (viewredo (car pl) al depth)))

#|

(defun viewresidueslast (pl al depth cont)
  (let (dum ans)
    (viewexit (car pl) al depth)
    (cond ((cdr pl) (viewresiduesdepth (cadr pl) (cdr pl) al depth cont))
          (cont (viewresiduesexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
          (t (setq ans (plugstdexp (reverse *residue*) alist))
             (setq dum (plugstdexp *variables* alist))
             (unless (equalp *variables* dum)
               (setq ans (nreconc (unroll *variables* dum) ans)))
             ;(dolist (var *variables*)
             ;  (unless (eq (setq dum (plugstdexp var alist)) var)
             ;    (setq ans (cons `(same ,var ,dum) ans))))
             (setq *answers* (adjoin (maksand ans) *answers* :test #'equalp))))))
|#

(defun viewresidueslast (pl al depth cont)
  (let (dum ans)
    (viewexit (car pl) al depth)
    (cond ((cdr pl) (viewresiduesdepth (cadr pl) (cdr pl) al depth cont))
          (cont (viewresiduesexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
          (t (setq ans (plugstdexp (reverse *residue*) alist))
             (setq dum (plugstdexp *variables* alist))
             (unless (equalp *variables* dum)
               (setq ans (cons `(same ,*variables* ,dum) ans)))
             ;(dolist (var *variables*)
             ;  (unless (eq (setq dum (plugstdexp var alist)) var)
             ;    (setq ans (cons `(same ,var ,dum) ans))))
             (setq *answers* (adjoin (maksand ans) *answers* :test #'equalp))))))

(defun demorgantrick (clauses)
  (do ((l clauses (cdr l)) (nl))
      ((null l) (nreverse nl))
      (do ((m (car l) (cdr m)) (nm))
          ((null m) (setq nl (cons (nreverse nm) nl)))
          (cond ((atom (car m)) (setq nm (cons `(not ,(car m)) nm)))
                ((eq (caar m) 'not) (setq nm (cons (cadar m) nm)))
                ((eq (caar m) 'same)
                 (setq nm (cons `(distinct ,(cadar m) ,(caddar m)) nm)))
                (t (setq nm (cons `(not ,(car m)) nm)))))))

(defun unroll (x y)
  (nreverse (unrollexp x y nil)))

(defun unrollexp (x y nl)
  (cond ((varp x)
         (if (and (varp y) (eq x y)) nl (cons `(same ,x ,y) nl)))
        ((atom x) (cond ((eq x y) nl)
                        ((varp y) (cons `(same ,x ,y) nl))
                        (t (cons 'false nl))))
        (t (do ((l x (cdr l)) (m y (cdr m)))
               ((null l) nl)
               (setq nl (unrollexp (car l) (car m) nl))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
