;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; (c) Copyright 1999-2005 by Michael Genesereth.  All rights reserved.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; data.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(eval-when (compile load eval)
  (proclaim '(special *thing* *answers* *sentences* *theory*)))

(defparameter *order* 'simple)

(defparameter *translate* t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; general
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun dbinsert (p th)
  (cond ((atom p) (addcontent p th) (index p p th) p)
        ((eq 'unprovable (car p)) (drop (cadr p) th))
        ((eq 'not (car p)) (drop (cadr p) th))
        ((eq 'and (car p)) (dolist (p (cdr p)) (dbinsert p th)) p)
        (t (addcontent p th) (index p p th) p)))

(defun dataenvindexps (p al th)
  (cond ((and (varp p) (varp (setq p (indval p th)))) (contents th))
        ((atom p) (indexees p th))
        (t (do ((l (cdr p) (cdr l)) (dum))
               ((null l) (indexps (car p) th))
               (setq dum (indval (car l) al))
               (cond ((varp dum))
                     ((atom dum) (return (indexees dum th))))))))

(defun knowledgeenvindexps (p al th)
  (cond ((and (varp p) (varp (setq p (indval p th)))) (contents th))
        ((atom p) (indexees p th))
        (t (do ((l (cdr p) (cdr l)) (dum) (best (car p)) (len)
                (size (length (indexees (car p) th))))
               ((null l) (indexps best th))
               (setq dum (indval (car l) al))
               (cond ((varp dum))
                     ((not (atom dum)))
                     ((< (setq len (length (indexees dum th))) size)
                      (setq best dum size len)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; datafindp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun datafindp (p th)
  (datafindx t p th))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; datafindx
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun datafindx (x p *theory*)
  (let ((dum) (*answers*))
    (setq p (order x p))
    (cond ((and *translate* (setq dum (planone x p)))
           (funcall (compiler dum) *theory*))
          ((setq dum (findone p truth nil)) (plug x dum)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; datafinds
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun datafinds (*thing* p *theory*)
  (let ((dum) (*answers*))
    (setq p (order *thing* p))
    (cond ((and *translate* (setq dum (planall *thing* p)))
           (funcall (compiler dum) *theory*))
          (t (findall p truth nil)
             (nreverse (uniquify *answers*))))))

(defun dataknownp (p th)
  (cond ((atom p) (knownx t p th))
        ((eq 'not (car p)) (dataunknownp (cadr p) th))
        (t (knownx t p th))))

(defun dataunknownp (p th)
  (and (not (truep p th))
       (every #'(lambda (th) (dataunknownp p th)) (includees th))))

(defun compiler (code)
  (handler-bind ((warning #'muffle-warning)) (compile nil code)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; planone
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *varcount* 0)
(defparameter *incount* 0)
(defparameter *outcount* 0)

(defun planone (x p)
  `(lambda (*theory*)
     ,(planoneexp x p nil)))

(defun planoneexp (x p al)
  (let ((*varcount* *varcount*) (*incount* *incount*) (*outcount* *outcount*))
    (cond ((atom p) (planoneatom x p al))
          ((eq 'not (car p)) (planonenot x (cadr p) al))
          ((eq 'and (car p)) (planoneand x p al))
          ((eq 'or (car p)) (planoneor x p al))
          ((eq 'same (car p)) (planonesame x p al))
          ((eq 'distinct (car p)) (planonedistinct x p al))
          ((eq 'oneof (car p)) (planoneoneof x p al))
          ((eq 'choose (car p)) (planonechoose x p al))
          ((eq 'bagofall (car p)) (planonebagofall x p al))
          ((eq 'unprovable (car p)) (planoneunprovable x (cadr p) al))
	  ((eq 'ground (car p)) (planoneground x p al))
	  ((eq 'nonground (car p)) (planonenonground x p al))
          ((eq 'execute (car p)) (planoneexecute x p al))
          ((eq 'evaluate (car p)) (planoneevaluate x p al))
          ((eq 'strmatch (car p)) (planonestrmatch x p al))
	  ((get (car p) 'basicval) (planonebasicval x p al))
          ((get (car p) 'basic) (planonebasic x p al))
          (t (planoneth x p al)))))

(defun planonenot (x p al)
  (cond ((atom p) (planonenotatom x p al))
        ((eq 'not (car p)) (planoneexp x (cadr p) al))
        ((eq 'and (car p)) (planonenotand x p al))
        ((eq 'or (car p)) (planonenotor x p al))
        ((eq 'same (car p)) nil)
        ((eq 'distinct (car p)) nil)
        ((eq 'oneof (car p)) nil)
        ((eq 'choose (car p)) nil)
        ((eq 'bagofall (car p)) (planonenotbagofall x p al))
        ((eq 'unprovable (car p)) (planoneexp x (cadr p) al))
        ((eq 'ground (car p)) nil)
        ((eq 'nonground (car p)) nil)
        ((eq 'execute (car p)) (planonenotexecute x p al))
        ((eq 'evaluate (car p)) (planonenotevaluate x p al))
        ((eq 'strmatch (car p)) (planonenotstrmatch x p al))
        ((get (car p) 'basicval) (planonenotbasicval x p al))
        ((get (car p) 'basic) (planonenotbasic x p al))
        (t (planoneunprovable x p al))))

(defun planoneatom (x p al)
  (cond ((eq 'true p) (makresult x al))
        ((eq 'cut p) (makresult x al))
        ((eq 'false p) nil)
        (t `(if (find ',p (indexees ',p *theory*)) ,(makresult x al)))))

(defun planonenotatom (x p al)
  (cond ((eq 'true p) nil)
        ((eq 'cut p) nil)
        ((eq 'false p) (makresult x al))))

(defun planoneand (x p al)
  (cond ((null (cdr p)) (makresult x al))
        ((null (cddr p)) (planoneexp x (cadr p) al))
        (t (let (var ins outs vl bl nl)
             (setq var (newvar))
             (setq ins (newin))
             (setq outs (newout))
             (setq vl (impvars nil (cdr p) (vars x)))
             (setq bl al)
             (setq nl (list `(setq ,ins ,(planalldepth (caddr vl) (cadr p) al))))
             (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))
                 ((null l))
                 (setq bl (cons (cons (car l) `(nth ,i ,var)) bl)))
             (do ((l (cddr p) (cdr l)) (vl (cddr vl) (cddr vl)) (dl (dependencies p)))
                 ((null (cdr l))
                  (setq nl (cons `(loop for ,var in ,ins
                                        for dum = ,(planoneexp x (car l) bl)
                                        do (if dum (return dum))) nl)))
                 (cond ((subsetp (caddr vl) (car vl)) ; was (subsetp (cadr vl) (car vl))
                        (setq nl (cons `(loop for ,var in ,ins
                                              when ,(planoneexp t (car l) bl)
                                              do ,(planalldone (caddr vl) bl outs)) nl))
                        (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)
                            (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))
                            (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl))))
                       (t  (setq nl (cons `(loop for ,var in ,ins
                                                 do ,(planallexp (caddr vl) (car l) bl outs)) nl))
                           (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)
                               (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))
                               (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl)))))
                 (setq bl al)
                 (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))
                     ((null l))
                     (setq bl (cons (cons (car l) `(nth ,i ,var)) bl))))
             `(let ((,ins) (,outs)) . ,(nreverse nl))))))

(defun planonenotand (x p al)
  (cond ((null (cdr p)) nil)
        ((null (cddr p)) (planonenot x (cadr p) al))
        (t (do ((l (cdr p) (cdr l)) (nl))
               ((null l) (cons 'or (nreverse nl)))
               (setq nl (cons (planonenot x (car l) al) nl))))))

(defun planoneor (x p al)
  (cond ((null (cdr p)) nil)
        ((null (cddr p)) (planoneexp x (cadr p) al))
        (t (do ((l (cdr p) (cdr l)) (nl))
               ((null l) (cons 'or (nreverse nl)))
               (setq nl (cons (planoneexp x (car l) al) nl))))))

(defun planonenotor (x p al)
  (planoneand x (cons 'and (mapcar #'maknot (cdr p))) al))

(defun planonesame (x p al)
  (cond ((groundedoutp (cadr p) al)
         (cond ((groundedoutp (caddr p) al)
                `(when (equalp ,(makresult (cadr p) al) ,(makresult (caddr p) al))
                   ,(makresult x al)))
               (t (makresult x (cons (cons (caddr p) (makresult (cadr p) al)) al)))))
        ((groundedoutp (caddr p) al)
         (makresult x (cons (cons (cadr p) (makresult (caddr p) al)) al)))
        (t (makresult x (cons (cons (caddr p) (quotify (cadr p))) al)))))

(defun planonedistinct (x p al)
  `(unless (equalp ,(makresult (cadr p) al) ,(makresult (caddr p) al))
     ,(makresult x al)))

(defun planoneoneof (x p al)
  (let (var test (alist al))
    (setq var (newvar))
    (setq test (codsand (maktestexp (cadr p) var nil)))
    (cond ((and (eq test t) (equal x (cadr p))) (quotify (caddr p)))
          (t `(loop for ,var in ',(cddr p)
                    when ,test
                    do (return ,(makresult x alist)))))))

(defun planonechoose (x p al)
  (let ((arg1) (arg2) (dum))
    (setq arg1 (planoneexp (cadr p) (caddr p) al))
    (setq arg2 (car (last p)))
    (cond ((groundp arg2) `(if (equalp ,arg1 ',arg2) ,(makresult x al)))
          ((setq dum (assoc arg2 al))
           `(if (equalp ,arg1 ,(cdr dum)) ,(makresult x al)))
          (t (setq al (cons (cons arg2 arg1) al))
             (makresult x al)))))

(defun planonebagofall (x p al)
  (let ((arg1) (arg2) (dum))
    (setq arg1 `(cons 'listof ,(planalldepth (cadr p) (caddr p) al)))
    (setq arg2 (car (last p)))
    (cond ((groundp  arg2) `(if (equalp ,arg1 ',arg2) ,(makresult x al)))
          ((setq dum (assoc arg2 al))
           `(if (equalp ,arg1 ,(cdr dum)) ,(makresult x al)))
          (t (setq al (cons (cons arg2 arg1) al))
             (makresult x al)))))

(defun planonenotbagofall (x p al)
  (let ((arg1) (arg2) (dum))
    (setq arg1 `(cons 'listof ,(planalldepth (cadr p) (caddr p) al)))
    (setq arg2 (car (last p)))
    (cond ((groundp  arg2) `(if (not (equalp ,arg1 ',arg2)) ,(makresult x al)))
          ((setq dum (assoc arg2 al))
           `(if (not (equalp ,arg1 ,(cdr dum))) ,(makresult x al)))
          (t ''bottom))))

(defun planoneunprovable (x p al)
  (setq p (deskolemize p))
  `(if (not ,(planoneexp t p al)) ,(makresult x al)))

(defun planoneground (x p al)
  (if (groundedoutp (cadr p) al) (makresult x al)))

(defun planonenonground (x p al)
  (cond ((groundedoutp (cadr p) al) nil)
        (t (makresult x al))))

(defun planonenotevaluate (x p al)
  (planonenotexecute x `(execute ,(cons (caadr p) (mapcar #'kwotify (cdadr p))) . ,(cddr p)) al))

(defun planoneexecute (x p al)
  (let (dum)
    (cond ((null (cddr p))
           `(if (ignore-errors ,(makcode (cadr p) al)) ,(makresult x al)))
          ((null (cdddr p))
           (cond ((groundp  (caddr p))
                  `(if (equalp (ignore-errors ,(makcode (cadr p) al)) ,(quotify (caddr p)))
                     ,(makresult x al)))
                 ((setq dum (assoc (caddr p) al))
                  `(if (equalp (ignore-errors ,(makcode (cadr p) al)) ,(cdr dum))
                     ,(makresult x al)))
                 (t (setq al (cons (cons (caddr p) (caddr p)) al))
                    `(let ((,(caddr p) (ignore-errors ,(makcode (cadr p) al))))
                       (if ,(caddr p) ,(makresult x al))))))
          (t (do ((l (cddr p) (cdr l)) (vars) (test))
                 ((null l) (setq vars (nreverse vars))
                  `(multiple-value-bind ,vars (ignore-errors ,(makcode (cadr p) al))
                     (if ,(maksand (cons (car vars) test)) ,(makresult x al))))
                 (setq vars (cons (newvar) vars))
                 (setq dum (maktest (car l) (car vars) al))
                 (unless (eq dum t) (setq test (cons dum test)))
                 (when (varp (car l)) (setq al (acons (car l) (car vars) al))))))))

(defun planonenotexecute (x p al)
  (let (dum)
    (cond ((null (cddr p))
           `(if (ignore-errors (not ,(makcode (cadr p) al))) ,(makresult x al)))
          ((null (cdddr p))
           (cond ((groundp  (caddr p))
                  `(if (not (equalp (ignore-errors ,(makcode (cadr p) al)) ,(quotify (caddr p))))
                     ,(makresult x al)))
                 ((setq dum (assoc (caddr p) al))
                  `(if (not (equalp (ignore-errors ,(makcode (cadr p) al)) ,(cdr dum)))
                     ,(makresult x al)))
                 (t `(if (ignore-errors (not ,(makcode (cadr p) al)))
                       ,(makresult x al)))))
          (t (do ((l (cddr p) (cdr l)) (vars) (test))
                 ((null l) (setq vars (nreverse vars))
                  `(multiple-value-bind ,vars (ignore-errors ,(makcode (cadr p) al))
                     (if (not ,(maksand (cons (car vars) test))) ,(makresult x al))))
                 (setq vars (cons (newvar) vars))
                 (setq dum (maktest (car l) (car vars) al))
                 (unless (eq dum t) (setq test (cons dum test)))
                 (when (varp (car l)) (setq al (acons (car l) (car vars) al))))))))

(defun planoneevaluate (x p al)
  (cond ((atom (cadr p)) (cadr p))
        (t (planoneexecute x `(execute ,(cons (caadr p) (mapcar #'kwotify (cdadr p))) . ,(cddr p)) al))))

(defun planonestrmatch (x p al)
  (planoneexecute x `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) al))

(defun planonenotstrmatch (x p al)
  (planonenotexecute x `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) al))

(defun planonebasicval (x p al)
  (let ((arg1) (arg2) (dum))
    (do ((l (cdr p) (cdr l)) (nl))
        ((null (cdr l)) (setq arg1 `(ignore-errors ,(cons (car p) (nreverse nl)))))
        (setq nl (cons (makresult (car l) al) nl)))
    (setq arg2 (car (last p)))
    (cond ((groundp  arg2) `(if (equalp ,arg1 ',arg2) ,(makresult x al)))
          ((setq dum (assoc arg2 al))
           `(if (equalp ,arg1 ,(cdr dum)) ,(makresult x al)))
          (t (setq al (cons (cons arg2 arg2) al))
             `(let ((,arg2 ,arg1)) (if ,(cdar al) ,(makresult x al)))))))

(defun planonenotbasicval (x p al)
  (let ((arg1) (arg2) (dum))
    (do ((l (cdr p) (cdr l)) (nl))
        ((null (cdr l)) (setq arg1 `(ignore-errors ,(cons (car p) (nreverse nl)))))
        (setq nl (cons (makresult (car l) al) nl)))
    (setq arg2 (car (last p)))
    (cond ((groundp  arg2) `(if (not (equalp ,arg1 ',arg2)) ,(makresult x al)))
          ((setq dum (assoc arg2 al))
           `(if (not (equalp ,arg1 ,(cdr dum))) ,(makresult x al)))
          (t ''bottom))))

(defun planonebasic (x p al)
  (let ((test))
    (setq test (cons (get (car p) 'basic)
                     (mapcar #'(lambda (x) (makresult x al)) (cdr p))))
    `(if (ignore-errors ,test) ,(makresult x al))))

(defun planonenotbasic (x p al)
  (let ((test))
    (setq test (cons (get (car p) 'basic)
                     (mapcar #'(lambda (x) (makresult x al)) (cdr p))))
    `(if (ignore-errors (not ,test)) ,(makresult x al))))

(defun planoneth (x p al)
  (do* ((l (cdr p) (cdr l)) (i 1 (1+ i)) (var (newvar)) (dum)
        (index (indexable p al *theory*)) (test `((equalp (nth 0 ,var) ',(car p)))))
       ((null l) `(loop for ,var in (indexees ,index *theory*)
                        when ,(maksand (nreverse test))
                        do (return ,(makresult x al))))
       (cond ((eq '?* (car l)))
             ((groundp (car l))
              (setq test (cons `(equalp (nth ,i ,var) ',(car l)) test)))
             ((setq dum (assoc (car l) al))
              (setq test (cons `(equalp (nth ,i ,var) ,(cdr dum)) test)))
             (t (setq al (cons (cons (car l) `(nth ,i ,var)) al))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; planall
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun planall (x p)
  `(lambda (*theory*)
     ,(planalldepth x p nil)))

(defun planalldepth (x p al)
  (let ((*varcount* *varcount*) (*incount* *incount*) (*outcount* *outcount*))
    (cond ((atom p) (planalldepthatom x p al))
          ((eq 'not (car p)) (planallold x p al))
          ((eq 'and (car p)) (planalldepthand x p al))
          ((eq 'or (car p)) (planallold x p al))
          ((eq 'same (car p)) (planallold x p al))
          ((eq 'distinct (car p)) (planallold x p al))
          ((eq 'oneof (car p)) (planallold x p al))
          ((eq 'choose (car p)) (planallold x p al))
          ((eq 'bagofall (car p)) (planallold x p al))
          ((eq 'unprovable (car p)) (planallold x p al))
          ((eq 'ground (car p)) (planallold x p al))
          ((eq 'nonground (car p)) (planallold x p al))
          ((eq 'execute (car p)) (planallold x p al))
          ((eq 'evaluate (car p)) (planallold x p al))
          ((eq 'strmatch (car p)) (planallold x p al))
          ((get (car p) 'basicval) (planallold x p al))
          ((get (car p) 'basic) (planallold x p al))
          (t (planalldepthth x p al)))))

(defun planalldepthatom (x p al)
  (cond ((eq 'true p) `(list ,(makresult x al)))
        ((eq 'cut p) `(list ,(makresult x al)))
        ((eq 'false p) nil)
        (t `(if (find ',p (indexees ',p *theory*)) (list ,(makresult x al))))))

(defun planalldepthand (x p al)
  (cond ((null (cdr p)) (planalldepth x 'true al))
        ((null (cddr p)) (planalldepth x (cadr p) al))
        (t (let (var ins outs vl bl nl)
             (setq var (newvar))
             (setq ins (newin) outs (newout))
             (setq vl (impvars nil (cdr p) (vars x)))
             (setq bl al)
             (setq nl (cons `(setq ,ins ,(planalldepth (caddr vl) (cadr p) al)) nl))
             (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))
                 ((null l))
                 (setq bl (cons (cons (car l) `(nth ,i ,var)) bl)))
             (do ((l (cddr p) (cdr l)) (vl (cddr vl) (cddr vl)) (dl (dependencies p)))
                 ((null (cdr l))
                  (cond ((subsetp (caddr vl) (car vl)) ; was (subsetp (cadr vl) (car vl))
                         (setq nl (cons `(loop for ,var in ,ins
                                               when ,(planoneexp t (car l) bl)
                                               do ,(planalldone x bl outs)) nl))
                         (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)
                             (setq nl (cons `(nreverse ,outs) nl))
                             (setq nl (cons `(nreverse (uniquify ,outs)) nl))))
                        (t  (setq nl (cons `(loop for ,var in ,ins
                                                  do ,(planallexp x (car l) bl outs)) nl))
                            (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)
                                (setq nl (cons `(nreverse ,outs) nl))
                                (setq nl (cons `(nreverse (uniquify ,outs)) nl))))))
                 (cond ((subsetp (caddr vl) (car vl)) ; was (subsetp (cadr vl) (car vl))
                        (setq nl (cons `(loop for ,var in ,ins
                                              when ,(planoneexp t (car l) bl)
                                              do ,(planalldone (caddr vl) bl outs)) nl))
                        (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)
                            (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))
                            (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl))))
                       (t  (setq nl (cons `(loop for ,var in ,ins
                                                 do ,(planallexp (caddr vl) (car l) bl outs)) nl))
                           (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)
                               (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))
                               (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl)))))
                 (setq bl al)
                 (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))
                     ((null l))
                     (setq bl (cons (cons (car l) `(nth ,i ,var)) bl))))
             `(let (,ins ,outs) . ,(nreverse nl))))))

(defun planalldepthth (x p al)
  (do* ((l (cdr p) (cdr l)) (i 1 (1+ i)) (var (newvar)) (dum)     ;;; (cdr p) -> p, 1 -> 0
        (index (indexable p al *theory*)) (one (onep (vars x) p al))
        (test `((equalp (nth 0 ,var) ',(car p)))))
       ((null l)
        (setq test (cons `(= (length ,var) ,i) test))
        `(loop for ,var in (indexees ,index *theory*)
               with answers
               when ,(maksand (nreverse test))
               do (setq answers (cons ,(makresult x al) answers))
               finally (return ,(if one '(nreverse answers) '(nreverse (uniquify answers))))))
       (cond ((eq '?* (car l)))
             ((groundp (car l))
              (setq test (cons `(equalp (nth ,i ,var) ',(car l)) test)))
             ((setq dum (assoc (car l) al))
              (setq test (cons `(equalp (nth ,i ,var) ,(cdr dum)) test)))
             (t (setq al (cons (cons (car l) `(nth ,i ,var)) al))))))

(defun tableindexable (p al)
  (cond ((atom p)
         (let (dum)
         (cond ((varp p)
                (if (setq dum (assoc p al)) (cdr dum)))
               ((atom p) (quotify p)))))
        (t (quotify (car p)))))

(defmethod indexable (p al th)
  (cond ((atom p)
         (let (dum)
         (cond ((varp p)
                (if (setq dum (assoc p al)) (cdr dum)))
               ((atom p) (quotify p)))))
        (t (do ((l (cdr p) (cdr l)) (dum))
               ((null l) (indexable (car p) al th))
               (cond ((varp (car l))
                      (if (setq dum (assoc (car l) al)) (return (cdr dum))))
                     ((atom (car l)) (return (quotify (car l)))))))))

(defparameter *duplicates* nil)

(defun onep (vl p al)
  (cond ((varp p) (or (find p vl) (assoc p al))) ; was (assoc p al)
        ((atom p))
        (t (do ((l p (cdr l)))
               ((null l) (not *duplicates*))
               (unless (onep vl (car l) al) (return nil))))))

(defun monotonicp (ul vl wl al)
  (let (il)
    (setq il (intersection ul wl))
    (and (determinesps il (set-difference ul wl) al)
         (determinesps il (set-difference vl wl) al))))

(defun determinesp (vl var al)
  (let (dum)
    (cond ((find var vl) t)
          ((setq dum (assoc var al))
           (determinesps vl (cdr dum) al)))))

(defun determinesps (ul vl al)
  (every #'(lambda (v) (determinesp ul v al)) vl))
 
(defun dependencies (p)
  (depends p truth))

(defun depends (p al)
  (let (var)
    (cond ((atom p) al)
          ((eq 'or (car p)) (depends (cadr p) al))
          ((eq 'and (car p)) (dolist (x (cdr p)) (setq al (depends x al))) al)
          ((eq 'unprovable (car p)) al)
          ((get (car p) 'basicval)
           (cond ((and (varp (setq var (car (last p)))) (not (groundedoutp var al)))
                  (do ((l (cdr p) (cdr l)) (nl))
                      ((null (cdr l)) (acons var (nreverse nl) al))
                      (when (varp (car l)) (setq nl (cons (car l) nl)))))
                 (t al)))
          (t (do ((l (cdr p) (cdr l)))
                 ((null l) al)
                 (when (varp (car l)) (setq al (cons (list (car l) 'no) al))))))))


(defun planallold (x p al)
  `(let ((answers))
     ,(planallexp x p al 'answers)
     ;(uniquify (nreverse answers))
     (nreverse answers)))

(defun planallexp (x p al where)
  (let ((*varcount* *varcount*) (*incount* *incount*) (*outcount* *outcount*))
    (cond ((atom p) (planallatom x p al where))
          ((eq 'not (car p)) (planallnot x (cadr p) al where))
          ((eq 'and (car p)) (planalland x p al where))
          ((eq 'or (car p)) (planallor x p al where))
          ((eq 'same (car p)) (planallsame x p al where))
          ((eq 'distinct (car p)) (planalldistinct x p al where))
          ((eq 'oneof (car p)) (planalloneof x p al where))
          ((eq 'choose (car p)) (planallchoose x p al where))
          ((eq 'bagofall (car p)) (planallbagofall x p al where))
          ((eq 'unprovable (car p)) (planallunprovable x (cadr p) al where))
	  ((eq 'ground (car p)) (planallground x p al where))
	  ((eq 'nonground (car p)) (planallnonground x p al where))
          ((eq 'execute (car p)) (planallexecute x p al where))
          ((eq 'evaluate (car p)) (planallevaluate x p al where))
          ((eq 'strmatch (car p)) (planallstrmatch x p al where))
	  ((get (car p) 'basicval) (planallbasicval x p al where))
          ((get (car p) 'basic) (planallbasic x p al where))
          (t (planallth x p al where)))))

(defun planallnot (x p al where)
  (cond ((atom p) (planallnotatom x p al where))
        ((eq 'not (car p)) (planallexp x (cadr p) al where))
        ((eq 'and (car p)) (planallnotand x p al where))
        ((eq 'or (car p)) (planallnotor x p al where))
        ((eq 'same (car p)) nil)
        ((eq 'distinct (car p)) nil)
        ((eq 'oneof (car p)) nil)
        ((eq 'choose (car p)) nil)
        ((eq 'bagofall (car p)) (planallnotbagofall x p al where))
        ((eq 'unprovable (car p)) (planallexp x (cadr p) al where))
        ((eq 'ground (car p)) nil)
        ((eq 'nonground (car p)) nil)
        ((eq 'execute (car p)) (planallnotexecute x p al where))
        ((eq 'evaluate (car p)) (planallnotevaluate x p al where))
        ((eq 'strmatch (car p)) (planallnotstrmatch x p al where))
        ((get (car p) 'basicval) (planallnotbasicval x p al where))
        ((get (car p) 'basic) (planallnotbasic x p al where))
        (t (planallunprovable x p al where))))

(defun planallatom (x p al where)
  (cond ((eq 'true p) (planalldone x al where))
        ((eq 'cut p) (planalldone x al where))
        ((eq 'false p) nil)
        (t `(if (find ',p (indexees ',p *theory*)) ,(planalldone x al where)))))

(defun planalland (x p al where)
  (cond ((null (cdr p)) (planalldone (makresult x al) al where))
        ((null (cddr p)) (planallexp x (cadr p) al where))
        (t (let (var ins outs vl bl nl)
             (setq var (newvar))
             (setq ins (newin))
             (setq outs (newout))
             (setq vl (impvars nil (cdr p) (vars x)))
             (setq bl al)
             (setq nl (list (planallexp (caddr vl) (cadr p) al outs)))
             (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl))
             (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))
                 ((null l))
                 (setq bl (cons (cons (car l) `(nth ,i ,var)) bl)))
             (do ((l (cddr p) (cdr l)) (vl (cddr vl) (cddr vl)) (dl (dependencies p)))
                 ((null (cdr l))
                  (cond ((subsetp (caddr vl) (car vl)) ; was (subsetp (cadr vl) (car vl))
                         (setq nl (cons `(loop for ,var in ,ins
                                               when ,(planoneexp t (car l) bl)
                                               do ,(planalldone x bl where)) nl)))
                        (t  (setq nl (cons `(loop for ,var in ,ins
                                                  do ,(planallexp x (car l) bl where)) nl)))))
                 (cond ((subsetp (caddr vl) (car vl)) ; was (subsetp (cadr vl) (car vl))
                        (setq nl (cons `(loop for ,var in ,ins
                                              when ,(planoneexp t (car l) bl)
                                              do ,(planalldone (caddr vl) bl outs)) nl))
                        (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)
                            (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))
                            (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl))))
                       (t  (setq nl (cons `(loop for ,var in ,ins
                                                 do ,(planallexp (caddr vl) (car l) bl outs)) nl))
                           (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)
                               (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))
                               (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl)))))
                 (setq bl al)
                 (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))
                     ((null l))
                     (setq bl (cons (cons (car l) `(nth ,i ,var)) bl))))
             `(let ((,ins) (,outs)) . ,(nreverse nl))))))

(defun impvars (ol pl nl)
  (cond ((null pl) (list nl))
        (t (let (vl)
             (setq nl (impvars (goodvarsform (car pl) ol) (cdr pl) nl))
             (setq vl (vars (car pl)))
             (list* (intersection ol (unionize vl (car nl))) vl nl)))))

(defun planallor (x p al where)
  (cond ((null (cdr p)) nil)
        ((null (cddr p)) (planallexp x (cadr p) al where))
        (t (do ((l (cdr p) (cdr l)) (nl))
               ((null l)
                (cons 'progn (nreverse (cons `(setq ,where (uniquify ,where)) nl))))
               (setq nl (cons (planallexp x (car l) al where) nl))))))

(defun planallsame (x p al where)
  (cond ((groundedoutp (cadr p) al)
         (cond ((groundedoutp (caddr p) al)
                `(when (equalp ,(makresult (cadr p) al) ,(makresult (caddr p) al))
                   ,(planalldone x al where)))
               (t (planalldone x (cons (cons (caddr p) (makresult (cadr p) al)) al) where))))
        ((groundedoutp (caddr p) al)
         (planalldone x (cons (cons (cadr p) (makresult (caddr p) al)) al) where))
        (t (planalldone x (cons (cons (caddr p) (quotify (cadr p))) al) where))))

(defun planalldistinct (x p al where)
  `(unless (equalp ,(makresult (cadr p) al) ,(makresult (caddr p) al))
     ,(planalldone x al where)))

(defun planalloneof (x p al where)
  (let (var test (alist al))
    (setq var (newvar))
    (setq test (codsand (maktestexp (cadr p) var nil)))
    (cond ((and (eq test t) (equal x (cadr p))) `(setq ,where (nreverse ',(cddr p))))
          (t `(loop for ,var in ',(cddr p)
                    when ,test
                    do ,(planalldone x alist where))))))

(defun planallchoose (x p al where)
  (let ((arg1) (arg2) (dum))
    (setq arg1 (planoneexp (cadr p) (caddr p) al))
    (setq arg2 (car (last p)))
    (cond ((groundp  arg2) `(if (equalp ,arg1 ',arg2) ,(planalldone x al where)))
          ((setq dum (assoc arg2 al))
           `(if (equalp ,arg1 ,(cdr dum)) ,(planalldone x al where)))
          (t (setq al (cons (cons arg2 arg2) al))
             `(let ((,arg2 ,arg1)) (if ,(cdar al) ,(planalldone x al where)))))))

(defun planallbagofall (x p al where)
  (let ((arg1) (arg2) (dum))
    (setq arg1 `(cons 'listof ,(planalldepth (cadr p) (caddr p) al)))
    (setq arg2 (car (last p)))
    (cond ((groundp  arg2) `(if (equalp ,arg1 ',arg2) ,(planalldone x al where)))
          ((setq dum (assoc arg2 al))
           `(if (equalp ,arg1 ,(cdr dum)) ,(planalldone x al where)))
          (t (setq al (cons (cons arg2 arg2) al))
             `(let ((,arg2 ,arg1)) (if ,(cdar al) ,(planalldone x al where)))))))

(defun planallnotbagofall (x p al where)
  (let ((arg1) (arg2) (dum))
    (setq arg1 `(cons 'listof ,(planalldepth (cadr p) (caddr p) al)))
    (setq arg2 (car (last p)))
    (cond ((groundp  arg2) `(if (not (equalp ,arg1 ',arg2)) ,(planalldone x al where)))
          ((setq dum (assoc arg2 al))
           `(if (not (equalp ,arg1 ,(cdr dum))) ,(planalldone x al where)))
          (t `(if ,arg1 ,(planalldone x al where))))))

(defun planallunprovable (x p al where)
  (setq p (deskolemize p))
  `(if (not ,(planoneexp t p al)) ,(planalldone x al where)))

(defun planallground (x p al where)
  (if (groundedoutp (cadr p) al) (planalldone x al where)))

(defun planallnonground (x p al where)
  (cond ((groundedoutp (cadr p) al) nil)
        (t (planalldone x al where))))

(defun planallexecute (x p al where)
  (let (dum)
    (cond ((null (cddr p))
           `(if (ignore-errors ,(makcode (cadr p) al)) ,(planalldone x al where)))
          ((null (cdddr p))
           (cond ((groundp  (caddr p))
                  `(if (equalp (ignore-errors ,(makcode (cadr p) al)) ,(quotify (caddr p)))
                     ,(planalldone x al where)))
                 ((setq dum (assoc (caddr p) al))
                  `(if (equalp (ignore-errors ,(makcode (cadr p) al)) ,(cdr dum))
                     ,(planalldone x al where)))
                 (t (setq al (cons (cons (caddr p) (caddr p)) al))
                    `(let ((,(caddr p) (ignore-errors ,(makcode (cadr p) al))))
                       (if ,(caddr p) ,(planalldone x al where))))))
          (t (do ((l (cddr p) (cdr l)) (vars) (test))
                 ((null l) (setq vars (nreverse vars))
                  `(multiple-value-bind ,vars (ignore-errors ,(makcode (cadr p) al))
                     (if ,(maksand (cons (car vars) test)) ,(planalldone x al where))))
                 (setq vars (cons (newvar) vars))
                 (setq dum (maktest (car l) (car vars) al))
                 (unless (eq dum t) (setq test (cons dum test)))
                 (when (varp (car l)) (setq al (acons (car l) (car vars) al))))))))

(defun planallevaluate (x p al where)
  (planallexecute x `(execute ,(cons (caadr p) (mapcar #'kwotify (cdadr p))) . ,(cddr p)) al where))

(defun planallstrmatch (x p al where)
  (planallexp x `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) al where))

(defun planallbasicval (x p al where)
  (let ((arg1) (arg2) (dum))
    (do ((l (cdr p) (cdr l)) (nl))
        ((null (cdr l)) (setq arg1 `(ignore-errors ,(cons (car p) (nreverse nl)))))
        (setq nl (cons (makresult (car l) al) nl)))
    (setq arg2 (car (last p)))
    (cond ((groundp  arg2) `(if (equalp ,arg1 ',arg2) ,(planalldone x al where)))
          ((setq dum (assoc arg2 al))
           `(if (equalp ,arg1 ,(cdr dum)) ,(planalldone x al where)))
          (t (setq al (cons (cons arg2 arg2) al))
             `(let ((,arg2 ,arg1)) (if ,(cdar al) ,(planalldone x al where)))))))

(defun planallnotbasicval (x p al where)
  (let ((arg1) (arg2) (dum))
    (do ((l (cdr p) (cdr l)) (nl))
        ((null (cdr l)) (setq arg1 `(ignore-errors ,(cons (car p) (nreverse nl)))))
        (setq nl (cons (makresult (car l) al) nl)))
    (setq arg2 (car (last p)))
    (cond ((groundp  arg2) `(if (not (equalp ,arg1 ',arg2)) ,(planalldone x al where)))
          ((setq dum (assoc arg2 al))
           `(if (not (equalp ,arg1 ,(cdr dum))) ,(planalldone x al where)))
          (t `(if ,arg1 ,(planalldone x al where))))))

(defun planallbasic (x p al where)
  (let ((test))
    (setq test (cons (get (car p) 'basic)
                     (mapcar #'(lambda (x) (makresult x al)) (cdr p))))
    `(if (ignore-errors ,test) ,(planalldone x al where))))

(defun planallth (x p al where)
  (do* ((l (cdr p) (cdr l)) (i 1 (1+ i)) (var (newvar)) (dum)
        (index (indexable p al *theory*))
        (test `((equalp (nth 0 ,var) ,(indexable (car p) al *theory*)))))
       ((null l) `(loop for ,var in (indexees ,index *theory*)
                        when ,(maksand (nreverse test))
                        do (setq ,where (cons ,(makresult x al) ,where))))
       (cond ((eq '?* (car l)))
             ((groundp (car l))
              (setq test (cons `(equalp (nth ,i ,var) ',(car l)) test)))
             ((setq dum (assoc (car l) al))
              (setq test (cons `(equalp (nth ,i ,var) ,(cdr dum)) test)))
             (t (setq al (cons (cons (car l) `(nth ,i ,var)) al))))))

(defun planalldone (x al where)
  `(setq ,where (cons ,(makresult x al) ,where)))


(defun planallnotatom (x p al where)
  (cond ((eq 'true p) nil)
        ((eq 'cut p) nil)
        ((eq 'false p) (planalldone x al where))))

(defun planallnotor (x p al where)
  (planalland x (cons 'and (mapcar #'maknot (cdr p))) al where))

(defun planallnotand (x p al where)
  (cond ((null (cdr p)) nil)
        ((null (cddr p)) (planallnot x (cadr p) al where))
        (t (do ((l (cdr p) (cdr l)) (nl))
               ((null l) (cons 'progn (nreverse nl)))
               (setq nl (cons (planallnot x (car l) al where) nl))))))

(defun planallnotvalue (x p al where)
  (cond ((every #'atom (cdr p))
         (planallnotbasicval x (append (cadr p) (cddr p)) al where))
        (t (setq p (nreverse (flatten p)))
           (rplaca p (maknot (car p)))
           (setq p (nreverse p))
           (planallexp x p al where))))

(defun planallnotexecute (x p al where)
  (let (dum)
    (cond ((null (cddr p))
           `(if (ignore-errors (not ,(makcode (cadr p) al))) ,(planalldone x al where)))
          ((null (cdddr p))
           (cond ((groundp  (caddr p))
                  `(if (not (equalp (ignore-errors ,(makcode (cadr p) al)) ,(quotify (caddr p))))
                     ,(planalldone x al where)))
                 ((setq dum (assoc (caddr p) al))
                  `(if (not (equalp (ignore-errors ,(makcode (cadr p) al)) ,(cdr dum)))
                     ,(planalldone x al where)))
                 (t `(if (ignore-errors (not ,(makcode (cadr p) al)))
                       ,(planalldone x al where)))))
          (t (do ((l (cddr p) (cdr l)) (vars) (test))
                 ((null l) (setq vars (nreverse vars))
                  `(multiple-value-bind ,vars (ignore-errors ,(makcode (cadr p) al))
                     (if (not ,(maksand (cons (car vars) test))) ,(planalldone x al where))))
                 (setq vars (cons (newvar) vars))
                 (setq dum (maktest (car l) (car vars) al))
                 (unless (eq dum t) (setq test (cons dum test)))
                 (when (varp (car l)) (setq al (acons (car l) (car vars) al))))))))

(defun planallnotevaluate (x p al where)
  (planallnotexecute x `(execute ,(cons (caadr p) (mapcar #'kwotify (cdadr p))) . ,(cddr p)) al where))

(defun planallnotstrmatch (x p al where)
  (planallnot x `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) al where))

(defun planallnotbasic (x p al where)
  (let ((test))
    (setq test (cons (get (car p) 'basic)
                     (mapcar #'(lambda (x) (makresult x al)) (cdr p))))
    `(if (ignore-errors (not ,test)) ,(planalldone x al where))))


(defun newvar ()
  (intern (stringappend "T" (princ-to-string (incf *varcount*)))))

(defun newin ()
  (intern (stringappend "IN" (princ-to-string (incf *incount*)))))

(defun newout ()
  (intern (stringappend "OUT" (princ-to-string (incf *outcount*)))))

(defun goodvars (p)
  (nreverse (goodvarsform p nil)))

(defun goodvarsform (p nl)
  (cond ((atom p) nl)
        ((eq 'ask (car p)) (goodvarsform (caddr p) nl))
        ((eq 'not (car p)) (goodvarsform (cadr p) nl))
        ((eq 'and (car p)) (goodvarsforms p nl))
        ((eq 'or (car p)) (goodvarsforms p nl))
        ((eq 'same (car p)) (goodvarsexps p nl))
        ((eq 'distinct (car p)) nl)
        ((eq 'oneof (car p)) (goodvarsexps p nl))
        ((eq 'bagofall (car p)) (goodvarsexp (cadddr p) nl))
        ((eq 'unprovable (car p)) nl)
        ((eq 'ground (car p)) nl)
        ((eq 'nonground (car p)) nl)
        ((eq 'execute (car p)) (goodvarsexps (cddr p) nl))
        ((eq 'evaluate (car p)) (goodvarsexps (cddr p) nl))
        ((eq 'strmatch (car p)) (goodvarsexps (cdddr p) nl))
        ((get (car p) 'basicval) (goodvarsexp (car (last p)) nl))
        ((get (car p) 'basic) nl)
        (t (goodvarsexps p nl))))

(defun goodvarsforms (p nl)
  (dolist (arg (cdr p)) (setq nl (goodvarsform arg nl)))
  nl)

(defun goodvarsexp (x nl)
  (cond ((or (eq x '?*) (eq x '@*)) nl)
        ((varp x) (adjoin x nl))
        ((atom x) nl)
        ((eq 'quote (car x)) nl)
        (t (goodvarsexps x nl))))

(defun goodvarsexps (x nl)
  (dolist (arg x) (setq nl (goodvarsexp arg nl)))
  nl)

(defun getnewvars (x al)
  (nreverse (getnewvarsexp x al nil)))

(defun getnewvarsexp (x al nl)
  (cond ((or (eq x '?*) (eq x '@*)) nl)
        ((varp x) (if (assoc x al) nl (adjoin x nl)))
        ((atom x) nl)
        ((eq 'quote (car x)) nl)
        ((eq 'nonground (car x)) nl)
        (t (dolist (arg x) (setq nl (getnewvarsexp arg al nl))) nl)))

(defun groundedoutp (x al)
  (cond ((varp x) (assoc x al))
        ((atom x))
        (t (do ((l x (cdr l)))
               ((null l) t)
               (unless (groundedoutp (car l) al) (return nil))))))

(defun destruct (x al)
  (cond ((varp x) (if (assoc x al) al (cons (cons x x) al)))
        ((atom x) al)
        (t (do ((l x (cdr l)) (i 0 (1+ i)))
               ((null l) al)
               (setq al (destruct (car l) al))))))

(defparameter alist nil)

(defun maksprogn (l)
  (cond ((null l) nil)
        ((null (cdr l)) (car l))
        (t (cons 'progn l))))

(defun maktest (x code alist)
  (codsand (nreverse (maktestexp x code nil))))

(defun maktestexp (x code tl)
  (cond ((eq '?* x) tl)
        ((varp x)
         (let (dum)
           (cond ((setq dum (assoc x alist))
                  (cons `(equalp ,code ,(cdr dum)) tl))
                 (t (setq alist (cons (cons x code) alist)) tl))))
        ((atom x) (cons `(equalp ,code ',x) tl))
        (t (do ((l x (cdr l)) (i 0 (1+ i)))
               ((null l) tl)
               (setq tl (maktestexp (car l) `(nth ,i ,code) tl))))))

(defun codsand (l)
  (cond ((null l))
        ((null (cdr l)) (car l))
        (t (cons 'and l))))

(defun makselflist (x al)
  (cond ((varp x) (acons x x al))
        ((atom x) al)
        (t (makselflist (cdr x) (makselflist (car x) al)))))

(defun makcode (x al)
  (let ((dum))
    (cond ((varp x) (cond ((setq dum (assoc x al)) (cdr dum))
                          (t (quotify x))))
          ((atom x) x)
          ((eq 'quote (car x)) x)
          ((eq 'kwote (car x)) (makcode2 (cadr x) al))
          (t (do ((l (cdr x) (cdr l)) (nl))
                 ((null l) (cons (car x) (nreverse nl)))
                 (setq nl (cons (makcode (car l) al) nl)))))))

(defun makcode2 (x al)
  (let ((dum))
    (cond ((varp x) (cond ((setq dum (assoc x al)) (cdr dum))
                          (t (quotify x))))
          ((atom x) (quotify x))
          (t (do ((l x (cdr l)) (nl))
                 ((null l) (cons 'list (nreverse nl)))
                 (setq nl (cons (makcode2 (car l) al) nl)))))))

(defun makresult (x al)
  (let ((dum))
    (cond ((varp x) (cond ((setq dum (assoc x al)) (cdr dum))
                          (t (quotify x))))
          ((atom x) (quotify x))
          ((eq 'quote (car x)) x)
          (t (do ((l x (cdr l)) (nl))
                 ((null l) (cons 'list (nreverse nl)))
                 (setq nl (cons (makresult (car l) al) nl)))))))

(defun flatten (p)
  (let ((*sentences*))
    (do ((l (cdr p) (cdr l)) (nl))
        ((null l) (setq p (cons (car p) (nreverse nl))))
        (setq nl (cons (flattenexp (car l)) nl)))
    (maksand (nreverse (cons p *sentences*)))))

(defun flattenexp (x)
  (cond ((atom x) x)
        (t (do ((l (cdr x) (cdr l)) (var (newindvar)) (nl))
               ((null l)
                (setq *sentences* (cons (cons (car x) (nreverse (cons var nl)))
                                        *sentences*))
                var)
               (setq nl (cons (flattenexp (car l)) nl))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Fullaskp
;;; appears redundant now
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun fullaskp (p sender receiver)
  (fullaskx t p sender receiver))

(defun fullaskx (x p sender receiver)
  (declare (ignore sender))
  (let ((*ancestry* t))
    (decludes 'epitheory)
    (empty 'epitheory)
    (includes 'epitheory receiver)
    (mapc #'(lambda (x) (save x 'epitheory))
          (contrapositives `(<= (answer ,x) ,p)))
    (findx x `(answer ,x) 'epitheory)))

(defun fullasks (x p sender receiver)
  (declare (ignore sender))
  (let ((*ancestry* t))
    (decludes 'epitheory)
    (empty 'epitheory)
    (includes 'epitheory receiver)
    (mapc #'(lambda (x) (save x 'epitheory))
          (contrapositives `(<= (answer ,x) ,p)))
    (finds x `(answer ,x) 'epitheory)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; resservers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod resfinds (x p *theory*)
  (finds x (maksor (residues x p *theory* #'irreduciblep))
         (car (includees *theory*))))

(defun irreduciblep (p)
  (do ((l (indexees p *theory*) (cdr l)) (op (oper p)))
      ((null l) t)
      (if (eq (oper (head (car l))) op) (return nil))))

(defun oper (p)
  (cond ((atom p) p)
        (t (oper (car p)))))

(defun head (p)
  (cond ((atom p) p)
        ((eq 'and (car p)) (cadr p))
        ((eq '<= (car p)) (cadr p))
        ((eq '=> (car p)) (car (last p)))
        (t p)))

(defun tail (p)
  (cond ((atom p) 'true)
        ((eq 'and (car p)) (maksand (cddr p)))
        ((eq '<= (car p)) (maksand (cddr p)))
        ((eq '=> (car p)) (maksand (butlast (cdr p))))
        (t 'true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; adjust
;;; adjustment eliminates distinction between unneeded variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *vars* nil)

(defun adjust (x p)
  (let ((*vars* (vars x)))
    (adjustvars p *vars*)
    (adjustexp p)))

(defun adjustvars (p vl)
  (cond ((varp p)
         (cond ((find p vl) (setq *vars* (adjoin p *vars*)) vl)
               (t (cons p vl))))
        ((atom p) vl)
        ((eq 'or (car p))
         (do ((l (cdr p) (cdr l)) (wl vl))
             ((null l) wl)
             (setq wl (union (adjustvars (car l) vl) wl))))
        (t (do ((l p (cdr l)))
               ((null l) vl)
               (setq vl (adjustvars (car l) vl))))))

(defun adjustexp (p)
  (cond ((indvarp p) (if (find p *vars*) p '?*))
        ((seqvarp p) (if (find p *vars*) p '@*))
        ((atom p) p)
        ((eq 'oneof (car p)) p)
        (t (mapcar #'adjustexp p))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; order
;;; *order* determines whether system orders before processing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun order (x p)
  (cond ((not *order*) p)
        ((eq *order* 'simplest) (simple p nil))
        ((eq *order* 'simple) (simple p nil))
        ((eq *order* 'greedy) (neworder x p))
        (t (unsimple p nil))))

(defun simple (p vl)
  (cond ((atom p) p)
        ((eq 'or (car p)) (simpleor p vl))
        ((eq 'and (car p)) (simpleand p vl))
        ((eq 'not (car p)) (list 'not (simple (cadr p) vl)))
        ((eq 'unprovable (car p)) (list 'unprovable (simple (cadr p) vl)))
        (t p)))

(defun simpleor (p vl)
  (do ((l (cdr p) (cdr l)) (dum) (nl))
      ((null l) (maksor (nreverse nl)))
      (setq dum (simple (car l) vl))
      (unless (eq dum 'false) (setq nl (cons dum nl)))))

(defun simpleand (p vl)
  (do ((cl (nreverse (conjuncts p nil))) (old) (new) (nl))
      ((null cl) (maksand (nreverse nl)))
      (multiple-value-setq (new old)
        (if (eq *order* 'simplest) (simplest cl vl) (simplebest cl vl)))
      (cond ((eq 'true new) (setq cl (delete old cl)))
            ((not (null new))
             (setq vl (addvars new vl))
             (setq nl (cons new nl) cl (delete old cl)))
            (t (return 'false)))))

(defun conjuncts (p nl)
  (cond ((atom p) (cons p nl))
        ((eq 'and (car p))
         (dolist (fact (cdr p)) (setq nl (conjuncts fact nl)))
         nl)
        (t (cons p nl))))

;;; Priorities in findbest:
;;;   builtins whose value is known now
;;;   builtins ready to go
;;;   completely ground logicals
;;;   indexed logicals
;;;   variable logicals
;;;
;;; Priorities in simplebest:
;;;   builtins whose value is known now
;;;   builtins ready to go
;;;   completely ground logicals
;;;   other logicals

(defun simplest (cl vl)
  (do ((l cl (cdr l)))
      ((null l) nil)
      (cond ((atom (car l)) (return (values (car l) (car l))))
            ((eq 'same (caar l))
             (when (or (groundedp (cadar l) vl) (groundedp (caddar l) vl))
               (return (values (car l) (car l)))))
            ((eq 'distinct (caar l))
             (if (groundedp (car l) vl) (return (values (car l) (car l)))))
            ((eq 'oneof (caar l))
             (when (or (groundedp (cadar l) vl)
                       (every #'(lambda (x) (groundedp x vl)) (cddar l)))
               (return (values (car l) (car l)))))
            ((eq 'stringify (caar l)) 
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((groundedp (caddar l) vl)
                    (return (values `(convertfromstring ,(caddar l) ,(cadar l)) (car l))))))
            ((eq 'stringappend (caar l)) 
             (cond ((almostp (car l) vl) (return (values (car l) (car l))))
                   ((cddddr (car l)))
                   ((groundedp (cadddr (car l)) vl)
                    (cond ((groundedp (cadar l) vl)
                           (return (values `(stringsubleft ,(cadddr (car l)) ,(cadar l) ,(caddar l)) (car l))))
                          ((groundedp (caddar l) vl)
                           (return (values `(stringsubright ,(cadddr (car l)) ,(caddar l) ,(cadar l)) (car l))))))))
            ((get (caar l) 'basicval)
             (if (almostp (car l) vl) (return (values (car l) (car l)))))
            ((get (caar l) 'basic)
             (if (groundedp (car l) vl) (return (values (car l) (car l)))))
            (t (return (values (car l) (car l)))))))

(defun simplebest (cl vl)
  (do ((l cl (cdr l)) (okay) (good) (better) (best))
      ((null l)
       (setq best (or best better good okay))
       (cond ((and (listp best) (eq 'unprovable (car best)))
              (values `(unprovable ,(simple (cadr best) vl)) best))
             (t (values best best))))
      (cond ((atom (car l)) (unless best (setq best (car l))))
            ((eq 'same (caar l))
             (cond ((or (groundedp (cadar l) vl) (groundedp (caddar l) vl))
                    (return (values (car l) (car l))))
                   ((not okay) (setq okay (car l)))))
            ((eq 'distinct (caar l))
             (if (groundedp (car l) vl) (return (values (car l) (car l)))))
            ((eq 'oneof (caar l))
             (cond ((or (groundedp (cadar l) vl)
                        (every #'(lambda (x) (groundedp x vl)) (cddar l)))
                    (return (values (car l) (car l))))
                   ((not okay) (setq okay (car l)))))
            ((eq 'ground (caar l))
             (cond ((or best better good okay)
                    (setq best (or best better good okay))
                    (return (values best best)))
                   ((groundedp (car l) vl) (return (values 'true (car l))))
                   (t (return nil))))
            ((eq 'nonground (caar l))
             (cond ((or best better good okay)
                    (setq best (or best better good okay))
                    (return (values best best)))
                   ((groundedp (cadar l) vl) (return nil))
                   (t (return (values 'true (car l))))))
            ((eq 'execute (caar l))
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((or best better good))
                   (t (return (values (car l) (car l))))))
            ((eq 'evaluate (caar l))
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((or best better good))
                   (t (return (values (car l) (car l))))))
            ((eq 'unprovable (caar l))
             (cond ((closedp (car l) vl)
                    (return (values `(unprovable ,(simple (cadar l) vl)) (car l))))
                   ((or best better good okay))
                   (t (setq okay (car l)))))
            ((eq 'bagofall (caar l))
             (cond ((groundedp (caddar l) (nconc (vars (cadar l)) vl))
                    (return (values `(bagofall ,(cadar l) ,(simple (caddar l) vl) ,(cadddar l)) (car l))))
                   ((or best better good okay))
                   (t (setq okay (car l)))))
            ((eq 'stringify (caar l)) 
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((groundedp (caddar l) vl)
                    (return (values `(convertfromstring ,(caddar l) ,(cadar l)) (car l))))))
            ((eq 'stringappend (caar l)) 
             (cond ((almostp (car l) vl) (return (values (car l) (car l))))
                   ((cddddr (car l)))
                   ((groundedp (cadddr (car l)) vl)
                    (cond ((groundedp (cadar l) vl)
                           (return (values `(strsubleft ,(cadddr (car l)) ,(cadar l) ,(caddar l)) (car l))))
                          ((groundedp (caddar l) vl)
                           (return (values `(strsubright ,(cadddr (car l)) ,(caddar l) ,(cadar l)) (car l))))))))
            ((eq 'stringmatch (caar l))
             (if (and (groundedp (cadar l) vl) (groundedp (caddar l) vl))
                 (return (values (car l) (car l)))))
            ((get (caar l) 'basicval)
             (if (almostp (car l) vl) (return (values (car l) (car l)))))
            ((get (caar l) 'basic)
             (if (groundedp (car l) vl) (return (values (car l) (car l)))))
            ((groundedp (car l) vl) (unless best (setq best (car l))))
            (t (unless good (setq good (car l)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Greedy algorithm -- smallest number of useful variables
;;; Not necessarily optimal since larger number vars might go away quickly
;;; Should probably consider check for fully bound keys for then 1 solution only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun neworder (x p)
  (cond ((atom p) p)
        ((eq 'or (car p)) (neworderor x p))
        ((eq 'and (car p)) (neworderand x p))
        ((eq 'not (car p)) (list 'not (neworder x (cadr p))))
        (t p)))

(defun neworderor (x p)
  (do ((l (cdr p) (cdr l)) (dum) (nl))
      ((null l) (maksor (nreverse nl)))
      (setq dum (neworder x (car l)))
      (unless (eq dum 'false) (setq nl (cons dum nl)))))

(defun neworderand (x p)
  (let ((vars (vars (cons x p))))
    (progv vars nil
      (incrementvars x)
      (incrementvars p)
      (do ((cl (copy-list (cdr p))) (old) (new) (nl) (vl))
          ((null cl) (maksand (nreverse nl)))
          (multiple-value-setq (new old) (neworderbest cl vl))
          (decrementvars old)
          (cond ((eq 'true new) (setq cl (delete old cl)))
                ((not (null new))
                 (setq vl (addvars new vl))
                 (setq nl (cons new nl) cl (delete old cl)))
                (t (return 'false)))))))

;;; Five cases:
;;;  already known success -- return immediately
;;;  best = ready to compute -- continue processing looking for already known
;;;  good = logical -- continue procesing looking for logical with fewer vars
;;;  okay = oneof or same or primitive with unbound variable (possible??)
;;;  already known failure -- return immediately

(defun neworderbest (cl vl)
  (do ((l cl (cdr l)) (score 0) (newscore) (okay) (good) (best))
      ((null l) (setq best (or best good okay)) (values best best))
      (cond ((atom (car l)) (unless best (setq best (car l))))
            ((eq 'same (caar l))
             (cond ((or (groundedp (cadar l) vl) (groundedp (caddar l) vl))
                    (return (values (car l) (car l))))
                   ((not okay) (setq okay (car l)))))
            ((eq 'distinct (caar l))
             (if (groundedp (car l) vl) (return (values (car l) (car l)))))
            ((eq 'oneof (caar l))
             (cond ((or (groundedp (cadar l) vl)
                        (every #'(lambda (x) (groundedp x vl)) (cddar l)))
                    (return (values (car l) (car l))))
                   ((not okay) (setq okay (car l)))))
            ((eq 'ground (caar l))
             (cond ((or best good okay)
                    (setq best (or best good okay))
                    (return (values best best)))
                   ((groundedp (car l) vl) (return (values 'true (car l))))
                   (t (return nil))))
            ((eq 'nonground (caar l))
             (cond ((or best good okay)
                    (setq best (or best good okay))
                    (return (values best best)))
                   ((groundedp (cadar l) vl) (return nil))
                   (t (return (values 'true (car l))))))
            ((eq 'execute (caar l))
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((or best good))
                   (t (return (values (car l) (car l))))))
            ((eq 'evaluate (caar l))
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((or best good))
                   (t (return (values (car l) (car l))))))
            ((eq 'unprovable (caar l))
             (cond ((groundedp (car l) vl) (return (values (car l) (car l))))
                   ((or best good))
                   (t (return (values (car l) (car l))))))
            ((eq 'bagofall (caar l))
             (cond ((groundedp (caddar l) (nconc (vars (cadar l)) vl))
                    (return (values `(bagofall ,(cadar l) ,(simple (caddar l) vl) ,(cadddar l)) (car l))))
                   ((or best good okay))
                   (t (setq okay (car l)))))
            ((get (caar l) 'basic)
             (if (groundedp (car l) vl) (return (values (car l) (car l)))))
            ((eq 'stringify (caar l)) 
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((groundedp (caddar l) vl)
                    (return (values `(convertfromstring ,(caddar l) ,(cadar l)) (car l))))))
            ((eq 'stringmatch (caar l))
             (if (and (groundedp (cadar l) vl) (groundedp (caddar l) vl))
                 (return (values (car l) (car l)))))
            ((get (caar l) 'basicval)
             (if (almostp (car l) vl) (return (values (car l) (car l)))))
            (t (cond (best)
                     ((not good) (setq good (car l) score (scorevars (car l))))
                     ((< (setq newscore (scorevars (car l))) score)
                      (setq good (car l) score newscore)))))))

(defun initializevars (x)
  (cond ((varp x) (set x 0))
        ((atom x))
        ((eq 'quote (car x)))
        (t (initializevars (car x))
           (initializevars (cdr x)))))

(defun incrementvars (x)
  (cond ((varp x) (set x (1+ (abs (varval x)))))
        ((atom x))
        ((eq 'quote (car x)))
        (t (incrementvars (car x))
           (incrementvars (cdr x)))))

(defun decrementvars (x)
  (cond ((varp x) (set x (1- (varval x))))
        ((atom x))
        ((eq 'quote (car x)))
        (t (decrementvars (car x))
           (decrementvars (cdr x)))))

(defun usefulvars (x)
  (cond ((varp x)
         (cond ((plusp (varval x)) (set x (- (varval x))) 1)
               (t 0)))
        ((atom x) 0)
        ((eq 'quote (car x)) 0)
        (t (+ (usefulvars (car x)) (usefulvars (cdr x))))))

(defun scorevars (x)
  (prog2 (decrementvars x)
         (usefulvars x)
         (incrementvars x)))

(defun varval (x)
  (if (and (boundp x) (numberp (setq x (eval x)))) x 0))

(defun showvars (x vl)
  (cond ((varp x) (if (assoc x vl) vl (acons x (varval x) vl)))
        ((atom x) vl)
        ((eq 'quote (car x)) vl)
        (t (showvars (cdr x) (showvars (car x) vl)))))


(defun unsimple (p vl)
  (cond ((atom p) p)
        ((eq 'or (car p)) (unsimpleor p vl))
        ((eq 'and (car p)) (unsimpleand p vl))
        ((eq 'not (car p)) (list 'not (unsimple (cadr p) vl)))
        ((eq 'unprovable (car p)) (list 'unprovable (unsimple (cadr p) vl)))
        (t p)))

(defun unsimpleor (p vl)
  (cond ((null (cdr p)) 'false)
        ((null (cddr p)) (cadr p))
        (t (do ((l (cdr p) (cdr l)) (dum) (nl))
               ((null l) (maksor (nreverse nl)))
               (setq dum (unsimple (car l) vl))
               (unless (eq dum 'false) (setq nl (cons dum nl)))))))

(defun unsimpleand (p vl)
  (do ((cl (copy-list (cdr p))) (old) (new) (nl))
      ((null cl) (maksand (nreverse nl)))
      (multiple-value-setq (new old) (findbest cl vl))
      (cond ((eq 'true new) (setq cl (delete old cl)))
            ((not (null new))
             (setq vl (addvars new vl))
             (setq nl (cons new nl) cl (delete old cl)))
            (t (return 'false)))))

(defun findbest (cl vl)
  (do ((l cl (cdr l)) (okay) (good) (better) (best))
      ((null l)
       (setq best (or best better good okay))
       (cond ((and (listp best) (eq 'unprovable (car best)))
              (values `(unprovable ,(unsimple (cadr best) vl)) best))
             (t (values best best))))
      (cond ((atom (car l)) (unless best (setq best (car l))))
            ((eq 'same (caar l))
             (cond ((or (groundedp (cadar l) vl) (groundedp (caddar l) vl))
                    (return (values (car l) (car l))))
                   ((not okay) (setq okay (car l)))))
            ((eq 'distinct (caar l))
             (if (groundedp (car l) vl) (return (values (car l) (car l)))))
            ((eq 'oneof (caar l))
             (cond ((or (groundedp (cadar l) vl)
                        (every #'(lambda (x) (groundedp x vl)) (cddar l)))
                    (return (values (car l) (car l))))
                   ((not okay) (setq okay (car l)))))
            ((eq 'ground (caar l))
             (cond ((or best better good okay)
                    (setq best (or best better good okay))
                    (return (values best best)))
                   ((groundedp (car l) vl) (return (values 'true (car l))))
                   (t (return nil))))
            ((eq 'nonground (caar l))
             (cond ((or best better good okay)
                    (setq best (or best better good okay))
                    (return (values best best)))
                   ((groundedp (cadar l) vl) (return nil))
                   (t (return (values 'true (car l))))))
            ((eq 'execute (caar l))
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((or best better good))
                   (t (return (values (car l) (car l))))))
            ((eq 'evaluate (caar l))
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((or best better good))
                   (t (return (values (car l) (car l))))))
            ((eq 'unprovable (caar l))
             (cond ((closedp (car l) vl)
                    (return (values `(unprovable ,(unsimple (cadar l) vl)) (car l))))
                   ((or best better good okay))
                   (t (setq okay (car l)))))
            ((eq 'bagofall (caar l))
             (cond ((groundedp (caddar l) (nconc (vars (cadar l)) vl))
                    (return (values `(bagofall ,(cadar l) ,(simple (caddar l) vl) ,(cadddar l)) (car l))))
                   ((or best better good okay))
                   (t (setq okay (car l)))))
            ((eq 'stringify (caar l)) 
             (cond ((groundedp (cadar l) vl) (return (values (car l) (car l))))
                   ((groundedp (caddar l) vl)
                    (return (values `(convertfromstring ,(caddar l) ,(cadar l)) (car l))))))
            ((eq 'stringappend (caar l)) 
             (cond ((almostp (car l) vl) (return (values (car l) (car l))))
                   ((cddddr (car l)))
                   ((groundedp (cadddr (car l)) vl)
                    (cond ((groundedp (cadar l) vl)
                           (return (values `(strsubleft ,(cadddr (car l)) ,(cadar l) ,(caddar l)) (car l))))
                          ((groundedp (caddar l) vl)
                           (return (values `(strsubright ,(cadddr (car l)) ,(caddar l) ,(cadar l)) (car l))))))))
            ((eq 'stringmatch (caar l))
             (if (and (groundedp (cadar l) vl) (groundedp (caddar l) vl))
                 (return (values (car l) (car l)))))
            ((get (caar l) 'basicval)
             (if (almostp (car l) vl) (return (values (car l) (car l)))))
            ((get (caar l) 'basic)
             (if (groundedp (car l) vl) (return (values (car l) (car l)))))
            ((groundedp (car l) vl) (unless best (setq best (car l))))
            ((indexedp (car l) vl) (unless better (setq better (car l))))
            (t (unless good (setq good (car l)))))))

(defun almostp (x vl)
  (cond ((varp x) (not (null (find x vl))))
        ((atom x))
        (t (do ((l (cdr x) (cdr l)))
               ((null (cdr l)) t)
               (unless (groundedp (car l) vl) (return nil))))))

(defun groundedp (x vl)
  (cond ((varp x) (not (null (find x vl))))
        ((atom x))
        (t (do ((l x (cdr l)))
               ((null l) t)
               (unless (groundedp (car l) vl) (return nil))))))

(defun closedp (x vl)
  (cond ((eq x '?*))
        ((varp x) (not (null (find x vl))))
        ((atom x))
        (t (do ((l x (cdr l)))
               ((null l) t)
               (unless (closedp (car l) vl) (return nil))))))

(defun indexedp (x vl)
  (cond ((atom x))
        (t (do ((l (cdr x) (cdr l)))
               ((null l) nil)
               (cond ((varp (car l)) (if (find (car l) vl) (return t)))
                     ((atom (car l)) (return t)))))))

;;; ((eq 'unprovable (car p)) (findall (cadr p) al pl))
;;; same still buggy after same x y when x gets grounded so does y.
;;; not unprovable buggy too.

(defun addvars (x vl)
  (cond ((atom x) vl)
        ((eq 'not (car x)) (addvars (cadr x) vl))
        ((eq 'and (car x)) (addvarscdr x vl))
        ((eq 'or (car x)) (addvarscdr x vl))
        ((eq 'same (car x)) (addvarssame x vl))
        ((eq 'distinct (car x)) vl)
        ((eq 'oneof (car x)) (addvarsexp (cadr x) vl))
        ((eq 'ground (car x)) vl)
        ((eq 'nonground (car x)) vl)
        ((eq 'execute (car x)) (addvarsexps (cddr x) vl))
        ((eq 'evaluate (car x)) (addvarsexps (cddr x) vl))
        ((eq 'unprovable (car x)) vl)
        ((eq 'bagofall (car x)) (addvarsexp (cadddr x) vl))
        ((eq 'stringmatch (car x)) (addvarsexps (cdddr x) vl))
        ((get (car x) 'basicval) (addvarsexp (car (last x)) vl))
        ((get (car x) 'basic) (addvarsexp (car (last x)) vl))
        (t (addvarsexp x vl))))

(defun addvarssame (x vl)
  (cond ((groundedp (cadr x) vl) (addvarsexp (caddr x) vl))
        ((groundedp (caddr x) vl) (addvarsexp (cadr x) vl))
        (t vl)))

(defun addvarscdr (x vl)
  (do ((l (cdr x) (cdr l)))
      ((null l) vl)
      (setq vl (addvars (car l) vl))))

(defun addvarsexp (x vl)
  (cond ((varp x) (adjoin x vl))
        ((atom x) vl)
        (t (do ((l x (cdr l)))
               ((null l) vl)
               (setq vl (addvarsexp (car l) vl))))))

(defun addvarsexps (x vl)
  (do ((l x (cdr l)))
      ((null l) vl)
      (setq vl (addvarsexp (car l) vl))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Relational algebra operations:
;;;
;;; Examples:
;;;  (select '((a b c) (a b d) (d e f)) #'(lambda (x y z) (equal x 'a)))
;;;  ((a b c) (a b d))
;;;
;;;  (project '((a b c) (a b d) (d e f)) 1 3)
;;;  ((a c) (a d) (d f))
;;;
;;;  (product '((a) (b)) '((c) (d)))
;;;  ((a c) (a d) (b c) (b d))
;;;
;;;  (union '((a) (b)) '((b) (c)))
;;;  ((a) (b) (c))
;;;
;;;  (difference '((a) (b)) '((b) (c)))
;;;  ((a))
;;;
;;;  (join '((a b) (b b)) '((b c) (b d) (e f)) 2 1)
;;;  ((a b c) (a b d) (b b c) (b b d))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun difference* (l1 l2)
  (do ((l l1 (cdr l)) (nl))
      ((null l) (nreverse nl))
      (unless (member (car l) l2 :test #'equalp) (setq nl (cons (car l) nl)))))

(defun union* (&rest args)
  (do ((l args (cdr l)) (nl))
      ((null l) (uniquify (nreverse nl)))
      (setq nl (revappend (car l) nl))))

(defun unionize (l m)
  (do ((n m (cdr n)) (nn))
      ((null n) (append l (nreverse nn)))
      (unless (find (car n) l :test #'equalp) (setq nn (cons (car n) nn)))))

(defun intersection* (&rest l)
  (cond ((null l) nil)
        ((null (cdr l)) (car l))
        (t (intersect (car l) (apply #'intersection* (cdr l))))))

(defun intersect (l m)
  (cond ((null l) nil)
        ((member (car l) m :test #'equalp) (cons (car l) (intersect (cdr l) m)))
        (t (intersect (cdr l) m))))

(defun select (r &rest conditions)
  (do ((l r (cdr l)) (nl))
      ((null l) (nreverse nl))
      (if (every #'(lambda (p) (apply p (car l))) conditions)
          (setq nl (cons (car l) nl)))))

(defun newselect (r &rest conditions)
  (do ((l r (cdr l)) (nl))
      ((null l) (nreverse nl))
      (do ((c conditions (cddr c)))
          ((null c) (setq nl (cons (car l) nl)))
          (unless (equalp (elt (car l) (1- (car c))) (cadr c)) (return nil)))))

(defun project (r &rest columns)
  (do ((l r (cdr l)) (nl))
      ((null l) (nreverse (uniquify nl)))
      (do ((m columns (cdr m)) (tuple))
          ((null m) (setq nl (cons (nreverse tuple) nl)))
          (setq tuple (cons (nth (1- (car m)) (car l)) tuple)))))

(defun product (p q)
  (do ((l p (cdr l)) (nl))
      ((null l) (nreverse nl))
      (do ((m q (cdr m)))
          ((null m))
          (setq nl (cons (append (car l) (car m)) nl)))))

;;; union and difference are the usual lisp definitions

(defun join (p q &rest columns)
  (setq columns (reverse columns))
  (do ((l p (cdr l)) (dum) (nl))
      ((null l) (nreverse nl))
      (do ((m q (cdr m)))
          ((null m))
          (if (setq dum (joinem (car l) (car m) columns))
              (setq nl (cons dum nl))))))

(defun joinem (t1 t2 columns)
  (do ((j 1 (1+ j)) (m t2 (cdr m)) (mate) (nm))
      ((null m) (append t1 (nreverse nm)))
      (cond ((null (setq mate (getf columns j))) (setq nm (cons (car m) nm)))
            ((equalp (nth (1- mate) t1) (car m)))
            (t (return nil)))))

(defun foreach (x instances y)
  (do ((l instances (cdr l)) (nl))
      ((null l) (nreverse nl))
      (setq nl (cons (plug y (matcher x (car l))) nl))))

#|
(setq *test* (make-instance 'database))

(do ((i 1 (1+ i)))
    ((> i 1000))
    (save `(p a ,i) *test*))

(do ((i 1 (1+ i)))
    ((> i 100))
    (save `(q ,i ,i) *test*))

(time (let (*translate*) (finds '(?x ?z) '(and (p ?x ?y) (q ?y ?z) ) *test*)))

(time (let ((*translate* t)) (finds '(?x ?z) '(and (p ?x ?y) (q ?y ?z) ) *test*)))
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;